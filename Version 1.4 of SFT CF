from __future__ import print_function
from __future__ import division
from __future__ import division  # so that 1/3=0.333 instead of 1/3=0
from psychopy import visual, core, data, event, logging, sound, gui
from psychopy.constants import *  # things like STARTED, FINISHED
import numpy as np  # whole numpy lib is available, prepend 'np.'
from numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray
from numpy.random import random, randint, normal, shuffle
import os  # handy system and path functions
import time
import copy
import math
import random
import numpy
from array import array
import datetime
from psychopy import prefs
prefs.general['audioLib'] = ['pygame']
from psychopy import visual,core,data,event,gui
from psychopy import sound
from psychopy.constants import *  # things like STARTED, FINISHED
import csv
#
#
#
#
#
#
#
# Last updated on: 22/11/2019
#
#
#
#
#
#
#
#
#

########################################################################################
# Draw a box to get experiment and participant information
########################################################################################
expName = u'Flashing_grid_task'  # Name the experiment
expInfo = {u'Session': u'001', u'Participant': u'001'} # What the box should ask for
dlg = gui.DlgFromDict(dictionary=expInfo, title=expName) # Draw the bloody box!
if dlg.OK == False: core.quit() # If "cancel" is clicked end the whole thing
expInfo['date'] = data.getDateStr()  # add a simple timestamp
expInfo['expName'] = expName
########################################################################################
########################################################################################


########################################################################################
# Where To Write File
########################################################################################
# Setup files for saving
if not os.path.isdir('Flash_Grid_Results'): # Create this folder wherever this script is saved
    os.makedirs('Flash_Grid_Results')  # If this fails (e.g. permissions) we will get error
filename = 'Flash_Grid_Experiment_' + '%s_%s' %(expInfo['Participant'], expInfo['date'])+'.txt'
print('filename used for data is ' +filename)
########################################################################################
########################################################################################


########################################################################################
# Define the window
########################################################################################
# flag for 'escape' or other condition => quit the exp
endExpNow = False

# Setup the Window
win = visual.Window(fullscr=True, screen=0, allowGUI=True, allowStencil=False,
    monitor='testMonitor', color='grey', colorSpace='rgb',
    blendMode='avg', useFBO=True,
    units='cm')
# store frame rate of monitor if we can measure it successfully
expInfo['frameRate']=win.getActualFrameRate()
if expInfo['frameRate']!=None:
    frameDur = 1.0/round(expInfo['frameRate'])
else:
    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess 
########################################################################################
########################################################################################


########################################################################################
# Changeable experimental parameters
########################################################################################
# Number of experimental trials
singletrials = 40     # Number of single trials PER block
pairedtrials = 208     # Number of paired trials PER block
practicetrials = 6   # Number of practice trials for single AND paired grid trials
singletrials_total = practicetrials+singletrials # The calculated TOTAL amount of practice and experimental single grid trials 
pairedtrials_total = practicetrials+pairedtrials# The calculated TOTAL amount of practice and experimental paired grid trials

# Text size:
textsize = 0.7

# Fixation cross:
fcross = visual.TextStim(win, text="+")  

# The total number of tirals for the paired grid coniditons:
sumtotal = 2 # This should be the same number as pairedtrials

# Block seperation text
sep_text ='''The last block of the experiment will now begin'''
seperation_text = visual.TextStim(win, text=sep_text, height=textsize)



####################
# Single trials text s1
####################
# Introduction text
one01 = '''During the experiment you will be presented with single and paired grid trials. During single grid trials, you will be presented with a sequence of trials each containing one flashing grid made up of a random number of blue and orange patches. An example grid is shown below.'''
introtext01 = visual.TextStim(win, text=one01,pos=(0.9, 11), height=textsize)  
one111 = '''Before each set of single grid trials you will be asked if there are either more Blue or Orange patches in the grid, which you must then answer on subsequent trials.'''
introtext019 = visual.TextStim(win, text=one111,pos=(0.9, 6), height=textsize) 
one1112 = '''E.g. for the example grid below you may be asked: "Does the grid have more Blue than Orange patches? Press 'z' for YES or 'm' for NO."'''
introtext0191 = visual.TextStim(win, text=one1112,pos=(0.5, 2), height=textsize) 
one1113 = '''Press the spacebar to continue...'''
introtext0192 = visual.TextStim(win, text=one1113,pos=(0.3, -9), height=textsize) 
# Introduction text 2.0
one0001 = '''For section 2 of the block, on each trial you will be shown two flashing grids with varying distances between the grids. Both grids will have a randomly assigned proportion of blue to orange patches. Your task on each tiral of this section of the block is to make a judgement on the proportion of colours in both grids. You will be given practice trials before each section. PRESS ANY KEY ON THE KEYBOARD TO CONTINUE...'''
introtext0001 = visual.TextStim(win, text=one0001, height=textsize)
# Practice text:
practice01 = '''Practice for single grid trials will now begin. For these practice trials you must answer the following question on each trial: Does the grid have more Blue than Orange Patches? Press "z" for YES or "m" for NO.'''
practicetext1 = visual.TextStim(win, text=practice01,pos=(0,3), height=textsize) 
# Practice text:
practice0199 = '''Press any key on the keyboard to begin the practice trials...'''
practicetext17 = visual.TextStim(win, text=practice0199,pos=(-0.5,-0.5), height=textsize)
# End of first part of the experiment text
two01 = '''Single grid trials have now finished.'''
endtext01 = visual.TextStim(win, text=two01,pos=(-2.8,1.5), height=textsize)  
two010 = '''Press any key on the keyboard to continue...'''
endtext010 = visual.TextStim(win, text=two010,pos=(-1.4,0), height=textsize) 





# Practice trials for blue
prac001bf = '''Practice trials for single grid trials have now finished.'''
endspractice_bf = visual.TextStim(win, text=prac001bf,pos=(-0.7,3), height=textsize) 
prac001b1 = '''On the next set of trials you must answer the following question: Does the grid have more Blue than Orange Patches? Press "z" for YES or "m" for NO.'''
endspractice_b1 = visual.TextStim(win, text=prac001b1,pos=(-0.5,0), height=textsize) 
prac001b2 = '''Press any key on the keyboard to begin the actual trials...'''
endspractice_b2 = visual.TextStim(win, text=prac001b2,pos=(-0.8,-3), height=textsize) 
# Practice trials for orange
prac001of = '''Practice trials for single grid trials have now finished.'''
endspractice_of = visual.TextStim(win, text=prac001of,pos=(-0.7,3), height=textsize) 
prac001o1 = '''On the next set of trials you must answer the following question: Does the grid have more Orange than Blue Patches? Press "z" for YES or "m" for NO.'''
endspractice_o1 = visual.TextStim(win, text=prac001o1,pos=(-0.5,0), height=textsize) 
prac001o2 = '''Press any key on the keyboard to begin the actual trials...'''
endspractice_o2 = visual.TextStim(win, text=prac001o2,pos=(-0.8,-3), height=textsize) 
# Break text
breaktext01 = '''You are now on a break. Press any key on the keyboard to end your break and continue with the task immediately ...'''
breaktext = visual.TextStim(win, text=breaktext01, height=textsize) 
# Text on each trial for single grid trials
sttextb = '''Does the grid have more Blue than Orange patches? Press "z" for YES or "m" for NO.'''
strialtextb =blockonetext = visual.TextStim(win, text=sttextb, pos=(0, 6), height=textsize)
# Text on each trial for single grid trials
sttexto = '''Does the grid have more Orange than Blue patches? Press "z" for YES or "m" for NO.'''
strialtexto =blockonetext = visual.TextStim(win, text=sttexto, pos=(0, 6), height=textsize)
# Correct practice trial text:
cres = '''CORRECT'''
correct_res =blockonetext = visual.TextStim(win, text=cres, pos=(0,0), height=1)
# Inccorect practice trial text:
icres = '''INCORRECT'''
incorrect_res =blockonetext = visual.TextStim(win, text=icres, pos=(0,0), height=1)

####################
####################

####################
# Paired trials text s1
####################
# Introduction text
one = '''Introduction text here.'''
introtext = visual.TextStim(win, text=one, height=textsize)  

# End of experiment text
two = '''Please wait...'''
endtext = visual.TextStim(win, text=two, height=textsize)  

# End of the whole experiment text 
two22 = '''The experiment has now finished!'''
endtext1 = visual.TextStim(win, text=two22, height=textsize)  

# Section 2 practice trials text:
section2prac = '''Practice trials for paired grid trials will now begin. PRESS ANY KEY ON THE KEYBOARD TO BEGIN THE PRACTICE TRIALS...'''
section2practice = visual.TextStim(win, text=section2prac, height=textsize)

# Text on each trial for paired grid BLUE trials
ttext = '''Are there more Blue than Orange patches in both grids?  Press "z" for YES or "m" for NO.'''
trialtextb =blockonetext = visual.TextStim(win, text=ttext, pos=(0, 6), height=textsize)

# Text on each trial for paired grid ORANGE trials
ttexto = '''Are there more Orange than Blue patches in both grids?  Press "z" for YES or "m" for NO.'''
trialtexto =blockonetext = visual.TextStim(win, text=ttexto, pos=(0, 6), height=textsize)

####################
####################

####################
# Paired trials text
####################

# Seperation text after block 1:
sep_text ='''The last block of the experiment will now begin. Press any key on the keyboard to start the last block of the experiment...'''
seperation_text = visual.TextStim(win, text=sep_text, height=textsize)

####################
####################

####################
# Single trials text s2
####################
# Introduction text
one01e = '''On the next set of trials you must answer the following question: Does the grid have more Blue than Orange Patches? Press "z" for Yes or "m" for NO.'''
introtext0122b = visual.TextStim(win, text=one01e,pos=(0.3,2.5), height=textsize)  
one01ee = '''Press any key on the keyboard to begin the trials...'''
introtext0122bb = visual.TextStim(win, text=one01ee,pos=(-0.2,-1), height=textsize)  
one01et = '''On the next set of trials you must answer the following question: Does the grid have more Orange than Blue Patches? Press "z" for Yes or "m" for NO.'''
introtext0122o = visual.TextStim(win, text=one01et,pos=(0.3,2.5), height=textsize)  
one01eet = '''Press any key on the keyboard to begin the trials...'''
introtext0122oo = visual.TextStim(win, text=one01eet,pos=(-0.2,-1), height=textsize)  
# Practice text:
practice01 = '''Practice trials for section 1 of block 2 will now begin. PRESS ANY KEY ON THE KEYBOARD TO BEGIN THE PRACTICE TRIALS...'''
practicetext122 = visual.TextStim(win, text=practice01, height=textsize) 
# End of first part of the experiment text
two01 = '''Single grid trials have now finshed.'''
endtext0122 = visual.TextStim(win, text=two01,pos=(-1.7,0.5), height=textsize)  
two019 = '''Press any key on the keyboard to continue...'''
endtext01229 = visual.TextStim(win, text=two019,pos=(-0.2,-1), height=textsize)  
# Practice trials
prac001 = '''Practice trials for Section 1 of block 2 have now ended. Press any key on the keyboard to begin the actual trials for section 1 of block 2...'''
endspractice22 = visual.TextStim(win, text=prac001, height=textsize) 
# Break text
breaktext01 = '''You are now on a break. Press any key on the keyboard to end your break and continue with the task immediately...'''
breaktext = visual.TextStim(win, text=breaktext01, height=textsize) 
# Text on each trial for single grid trials
sttextb = '''Does the grid have more Blue than Orange patches? Press "z" for YES or "m" for NO.'''
strialtextb =blockonetext = visual.TextStim(win, text=sttextb, pos=(0, 6), height=textsize)
# Text on each trial for single grid trials
sttexto = '''Does the grid have more Orange than Blue patches? Press "z" for YES or "m" for NO.'''
strialtexto =blockonetext = visual.TextStim(win, text=sttexto, pos=(0, 6), height=textsize)
# Correct practice trial text:
cres = '''CORRECT'''
correct_res =blockonetext = visual.TextStim(win, text=cres, height=1)
# Inccorect practice trial text:
icres = '''INCORRECT'''
incorrect_res =blockonetext = visual.TextStim(win, text=icres, height=1)
# Practice trials
prac002 = '''Practice for paired grid trials has now finished.'''
endspractice2 = visual.TextStim(win, text=prac002,pos=(0,1.8), height=textsize) 

prac0020 = '''Press any key on the keyboard to begin the actual paired grid trials...'''
endspractice20 = visual.TextStim(win, text=prac0020, pos=(-0.3,0), height=textsize) 

####################
####################

####################
# Paired trials text s2
####################
# Introduction text
one = '''Introduction text here.'''
introtext = visual.TextStim(win, text=one, height=textsize)  

# End of experiment text
two = '''Please take a short break now, before continuing ...'''
endtext = visual.TextStim(win, text=two, height=textsize)  
# End of the whole experiment text 
two22 = '''The experiment has now finished!'''
endtext1 = visual.TextStim(win, text=two22, height=textsize)  
# Section 2 practice trials text:
section2prac = '''During paired grid trials, you will be presented with a sequence of trials each containing two flashing grids made up of a random number of blue and orange patches. Example grids are shown below.'''
section2practice22i = visual.TextStim(win, text=section2prac,pos=(0.9, 11), height=textsize)
one111t = '''Before each set of trials you will be asked if there are either more Blue or Orange patches in both grids, which you must then answer on subsequent trials.'''
section2practice22ii = visual.TextStim(win, text=one111t,pos=(1.2, 6), height=textsize) 
one1112t = '''E.g. for the example grids below you may be asked: "Are there more Orange than Blue patches in both grids? Press "z" for YES or "m" for NO."'''
section2practice22iii = visual.TextStim(win, text=one1112t,pos=(1.2, 2), height=textsize) 
one1113t = '''Press the spacebar to continue...'''
section2practice22iiii = visual.TextStim(win, text=one1113t,pos=(0.3, -10), height=textsize) 
practice01r = '''Practice trials for paired grids will now begin. For these practice trials you must answer the following question on each trial: Do both grids seperately have more Orange than Blue Patches? Press "z" for YES and "m" for NO.'''
practicetext1q = visual.TextStim(win, text=practice01r,pos=(0,3), height=textsize) 
# Practice text:
practice0199r = '''Press any key on the keyboard to begin the practice trials...'''
practicetext1qq = visual.TextStim(win, text=practice0199r,pos=(-0.5,0), height=textsize)
# Text on each trial for paired grid BLUE trials
ttext = '''Are there more Blue than Orange patches in both grids?  Press "z" for YES or "m" for NO.'''
trialtextb =blockonetext = visual.TextStim(win, text=ttext, pos=(0, 6), height=textsize)
# Text on each trial for paired grid ORANGE trials
ttexto = '''Are there more Orange than Blue patches in both grids?  Press "z" for YES or "m" for NO.'''
trialtexto =blockonetext = visual.TextStim(win, text=ttexto, pos=(0, 6), height=textsize)

# Block one intro text
bb1 = '''During the next set of trials two grids will be presented on screen with a moderate amount of seperation between them. On each trial you must answer the following question: Are there more Blue than Orange patches in both grids?  Press "z" for YES or "m" for NO.'''
blockonetext = visual.TextStim(win, text=bb1,pos=(0.3,2.5), height=textsize) 

# Block three intro text
bb3 = '''During the next set of trials two grids will be presented on screen with a moderate amount of seperation between them. On each trial you must answer the following question: Are there more Orange than Blue patches in both grids?  Press "z" for YES or "m" for NO.'''
blockthirdtext = visual.TextStim(win, text=bb3,pos=(0.3,2.5), height=textsize) 

# Block two intro text
bb2 = '''During the next set of trials two grids will be presented on screen close together. On each trial you must answer the following question: Are there more Orange than Blue patches in both grids?  Press "z" for YES or "m" for NO.'''
blocktwotext = visual.TextStim(win, text=bb2,pos=(0,2.5), height=textsize)

# Block four intro text
bb4 = '''During the next set of trials two grids will be presented on screen close together. On each trial you must answer the following question: Are there more Blue than Orange patches in both grids?  Press "z" for YES or "m" for NO.'''
blockfourthtext = visual.TextStim(win, text=bb4,pos=(0,2.5), height=textsize)

# Practice trials
prac002 = '''Practice trials for Section 2 of block 2 have now finished. Press any key on the keyboard to begin the actual trials for Section 2...'''
endspractice222 = visual.TextStim(win, text=prac002,pos=(0,0), height=textsize)  
# introduction to section 2 of block 2
sec2sec = '''Another set of paired grid trials will now begin.'''
sec_2 = visual.TextStim(win, text=sec2sec,pos=(0,2), height=textsize) 
sec2sec9 = '''Press any key on the key board to begin the trials...'''
sec_29 = visual.TextStim(win, text=sec2sec9,pos=(-0.3,0), height=textsize) 
# Block one intro text
bb150 = '''Press any key on the keyboard to begin the trials...'''
blockonetext150 = visual.TextStim(win, text=bb150,pos=(-0.3,-1), height=textsize) 
####################
####################


# Orange:
color1 = [0.9686,0.6392,0.0353]
# Blue:
color2 = [-0.8980,1.0000,1.0000] 

# Define some clocks
checkclock01 = core.Clock() # For single grid trials     S1
checkclock = core.Clock() # For paired grid trials       P1
checkclock01s2 = core.Clock() # For single grid trials   S2
checkclock = core.Clock() # For paired grid trials       P2
########################################################################################
########################################################################################


########################################################################################
# List That Will Record Responses & RTs
########################################################################################
# For single grid trials s1
keyspressed = []*singletrials
correctresponse = []*singletrials
RT =[]*singletrials
trialNo = []*singletrials
conused = []*singletrials
difflevel = []*singletrials
colourcolour1 = []*singletrials

# For single grid trials s2
keyspresseds2 = []*singletrials
correctresponses2 = []*singletrials
RTs2 =[]*singletrials
trialNos2 = []*singletrials
conused2 = []*singletrials
difflevel2 = []*singletrials
colourcolour2 = []*singletrials

# For paired grid trial p1:
keyspressed2 = []*pairedtrials
correctresponse2 = []*pairedtrials
RT2 =[]*pairedtrials
trialNo2 = []*pairedtrials
conused3 = []*pairedtrials
blocknumber = []*pairedtrials
difflevel3 = []*pairedtrials

# For paired grid trial p2:
keyspressed2p2 = []*pairedtrials
correctresponse2p2 = []*pairedtrials
RT2p2 =[]*pairedtrials
trialNo2p2 = []*pairedtrials
conused4 = []*pairedtrials
blocknumberp2 = []*pairedtrials
difflevel4 = []*pairedtrials

# Initilise the colour variable:
colour = []
########################################################################################
########################################################################################


########################################################################################
# Set the conditions for the single grid trials
########################################################################################
con1 = (1)
con2 = (2)
con3 = (3)
con4 = (4)
con5 = (5)
con6 = (6)
con7 = (7)
con8 = (8)
con9 = (9)
con10 = (10)

# Define the blue and orange block signle grid trials:
singleconditions_all = []


for i in range(5):
# The single grid trials for the blue block:
    singleconditions_all.append(con1)
    singleconditions_all.append(con2)
    singleconditions_all.append(con3)
    singleconditions_all.append(con4)
# The single grid trials for the orange block:
    singleconditions_all.append(con5)
    singleconditions_all.append(con6)
    singleconditions_all.append(con7)
    singleconditions_all.append(con8)
np.random.shuffle(singleconditions_all)

# Conditions for practice trials:
singlegridpractice = [1,5,3,4,7,8]
np.random.shuffle(singlegridpractice) # Randomly shuffle single grid practice trials


# Create and shuffle which colour block participants will see first:
colour_order = [1,2] # 1 is the colour blue and 2 is the colour orange
np.random.shuffle(colour_order)
########################################################################################
########################################################################################






########################################################################################
########################################################################################
########################################################################################
# Single Grid Trials INTRODUCTION
########################################################################################
########################################################################################
########################################################################################
# Initialize components for Routine "init_experiment"
init_experimentClock = core.Clock()
# set_colors()
# Colors used during the experiment.s
def set_colors():
    global sc_c # screen color
    global f_c # frame color
    global sq_c # square color
    # 1 = white
    # -0.06 = grey 80
    # -0.37 = grey 120
    # -1 = black
    sc_c = 1
    f_c = -0.06
    sq_c = -0.37
    t_c = -0.06

# set_sizes()
# Sizes used during the experiment
def set_sizes():
    global f_s # frame size (square) (frame surrounding the stimulus)
    global sq_s # square size (square where the stimulus is shown)
    global l_s # line size (the width of the line surrounding the stimulus)
    f_s = 240
    sq_s = 200
    l_s = 200
    
# Set the position of left stimulus
def set_positions01():
    global fl_p3 # Where should the flash be drawn
    fl_p3 = [0, -4]

########################################################################################
# Set main conditions and loop
########################################################################################
    
p01 = .65#(65/35)

# flash stimulus functions
# flash initialization
def flash_init(win, position01=[0,0], square_size=10, columns=20, rows=20, percent_color01=p01): # Colour2 being manipulated whic is BLUE
    global flash01 # The flash stimulus (an array of flashing squares)

    color_set01 = [color2, color1] # color2 being manipulated which is the BLUE
    cell_number = columns * rows

    num_color4 = int(np.floor(float(cell_number)*percent_color01)) # First colour
    num_color5 = int(np.floor(float(cell_number)*(1-percent_color01))) # Second colour
    
    # fill an array with colors. Each color should appear approximatively the same number of times.
    f_colors3 = []
    for i in range(num_color4):
        f_colors3.append(color_set01[0])
    for i in range(num_color5):
        f_colors3.append(color_set01[1])
    numpy.random.shuffle(color_set01)
    i = cell_number - len(f_colors3)
    while i > 0:
        f_colors3.append(color_set01[i])
        i -= 1
    
    # randomize color order.
    shuffle(f_colors3)
    
    # fill an array with coordinate for each color square. First square should be at the upper left
    # and next should follow from left to right and up to down.
    xys = []
    x_left = (1 - columns) * square_size / 2
    y_top = (1 - rows) * square_size / 2
    for l in range(rows):
        for c in range(columns):
            xys.append((x_left + c * square_size, y_top + l * square_size))
    
    
    # fill an array with coordinate for each color square. First square should be at the upper left
    # and next should follow from left to right and up to down.
    xys2 = []
    x_left = (1 - columns) * square_size / 2
    y_top = (1 - rows) * square_size / 2
    for l in range(rows):
        for c in range(columns):
            xys2.append((x_left + c * square_size, y_top + l * square_size))
    
    # MAIN FUNCTION TO CREATE FIRST GRID
    flash01 = visual.ElementArrayStim(win=win,
                        fieldPos=position01,
                        fieldShape='sqr',
                        nElements=cell_number,
                        sizes=square_size,
                        xys=xys,
                        colors=f_colors3,
                        elementTex=None,
                        elementMask=None,
                        name='flash',
                        autoLog=False)
                        
                        
                        

# flash stimulus change
def flash_change():
    global flash01
    shuffle(flash01.colors)
    flash01.setColors(flash01.colors)

# Time variables used during the experiment
def set_timing():
    global f_t 
    f_t = 5 # The duration (in frame) of a flash image presentation

# data_init
set_colors()
set_sizes()
set_positions01()
set_timing()

#############################
# MAIN FUNCTION HERE
flash_init(win, fl_p3, square_size=0.3, columns=20, rows=20) # set the parameters here for the function!!
#############################

# Initialize components for Routine "show_flash"
show_flashClock01 = core.Clock()
frame_fl = visual.ImageStim(win=win, name='frame_fl',
    image=None, mask=None,
    ori=0, pos=fl_p3, size=f_s,
    color=f_c, colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)

# Create some handy timers
globalClock01 = core.Clock()  # to track the time since experiment started
routineTimer01 = core.CountdownTimer()  # to track time remaining of each (non-slip) routine 

#------Prepare to start Routine "init_experiment"-------
t = 0
frameN = -1

#------Prepare to start Routine "show_flash"-------
t = 0
show_flashClock01.reset()  # clock 
frameN = -1
# update component parameters for each repeat
# flash begin routine
f_change = 0

# keep track of which components have finished
show_flashComponents01 = []
show_flashComponents01.append(frame_fl)
for thisComponent in show_flashComponents01:
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
########################################################################################
########################################################################################

#---Start Routine "show_flash"-------
continueRoutine = True
while continueRoutine:
#        thecount = thecount+1
#        print("The count =", thecount)
#        
#        if thecount == 1:
#            rtclock.reset() # Reset the clock here
        
    # Hides mouse
    mouse = event.Mouse(visible=0)
    
    # get current time
    t = show_flashClock01.getTime()
    #print("t =", t)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    
    # update/draw components on each frame
    #print(frameN)
    
    # *frame_fl* updates
    if t >= 0.0 and frame_fl.status == NOT_STARTED:
        # keep track of start time/frame for later
        frame_fl.tStart = t  # underestimates by a little under one frame
        frame_fl.frameNStart = frameN  # exact frame index
        frame_fl.draw()
    # flash each frame
    if frameN >= f_change:
        flash_change()
        f_change += f_t
    introtext01.draw()
    introtext019.draw()
    introtext0191.draw()
    introtext0192.draw()
    #introtext0001.draw()
    flash01.draw()  # First stimulus is drawn here
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineTimer01.reset()  # if we abort early the non-slip timer needs reset
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in show_flashComponents01:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    if event.getKeys(keyList=["space"]):
        break
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()
    else:  # this Routine was not non-slip safe so reset non-slip timer
        routineTimer.reset()
    
        
#-------Ending Routine "show_flash"-------
for thisComponent in show_flashComponents01:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
########################################################################################
########################################################################################
win.flip()











########################################################################################
########################################################################################
########################################################################################
# Single Grid Trials - First Block
########################################################################################
########################################################################################
########################################################################################
# Initialize components for Routine "init_experiment"
init_experimentClock = core.Clock()
# set_colors()
# Colors used during the experiment.s
def set_colors():
    global sc_c # screen color
    global f_c # frame color
    global sq_c # square color
    # 1 = white
    # -0.06 = grey 80
    # -0.37 = grey 120
    # -1 = black
    sc_c = 1
    f_c = -0.06
    sq_c = -0.37
    t_c = -0.06

# set_sizes()
# Sizes used during the experiment
def set_sizes():
    global f_s # frame size (square) (frame surrounding the stimulus)
    global sq_s # square size (square where the stimulus is shown)
    global l_s # line size (the width of the line surrounding the stimulus)
    f_s = 540
    sq_s = 800
    l_s = 100
    
# Set the position of left stimulus
def set_positions01():
    global fl_p3 # Where should the flash be drawn
    fl_p3 = [0, 0]

########################################################################################
# Set main conditions and loop
########################################################################################

# Counter to keep track of things
counter = 0
thecount = 0
counter01 = 0
thecount01 = 0
pcounter = 1
pcounter2 = 1

# Set the colour order for the first colour block:
colour_order1 = colour_order[0]

for j in range(singletrials_total): 
    
    if pcounter <= practicetrials:
        singleconditionsx = singlegridpractice[pcounter-1]
        if singleconditionsx >= 5:
            colour_order1 ==2 # ORANGE
        else:
            colour_order1 == 1 # BLUE
    else:
        # Select what condition is to be performed on experimental trials:
        if colour_order1 == 1: # BLUE
            singleconditionsx = singleconditions_all[counter01]
        elif colour_order1 == 2: # ORANGE
            singleconditionsx = singleconditions_all[counter01]
    
    
    if pcounter > practicetrials:
        # Append the condition we're on:
        if singleconditionsx == 1:
            conused.append('b,o')
            difflevel.append('Exp - Hard 1')
        elif singleconditionsx == 2:
            conused.append('b,o')
            difflevel.append('Exp - Hard 2')
        elif singleconditionsx == 3:
            conused.append('B,o')
            difflevel.append('Con - Easy 1')
        elif singleconditionsx == 4:
            conused.append('B,o')
            difflevel.append('Con - Easy 2')
        elif singleconditionsx == 5:
            conused.append('o,b')
            difflevel.append('Exp - Hard 1')
        elif singleconditionsx == 6:
            conused.append('o,b')
            difflevel.append('Exp - Hard 2')
        elif singleconditionsx == 7:
            conused.append('O,b')
            difflevel.append('Con - Easy 1')
        elif singleconditionsx == 8:
            conused.append('O,b')
            difflevel.append('Con - Easy 2')
    
    # Set the conditions here:
    # Blue colours:
    if singleconditionsx == 1:
        p01 = .52#(48/52)
    elif singleconditionsx == 2:
        p01 = .54#(46/54)
    elif singleconditionsx == 3:
        p01 = .60#(60/40)
    elif singleconditionsx == 4:
        p01 = .65#(65/35)
    
    # Orange colours:
    elif singleconditionsx == 5:
        p01 = .52#(48/52)
    elif singleconditionsx == 6:
        p01 = .54#(46/54)
    elif singleconditionsx == 7:
        p01 = .60#(60/40)
    elif singleconditionsx == 8:
        p01 = .65#(65/35)
        
        
    print('condition ======================', singleconditionsx)
    print('Colour ======================', colour_order1)
    print('p01 ======================', p01)
        
        
    # flash stimulus functions
    # flash initialization
    def flash_init(win, position01=[0,0], square_size=10, columns=20, rows=20, percent_color01=p01): # Colour2 being manipulated whic is BLUE
        global flash01 # The flash stimulus (an array of flashing squares)
        
        if singleconditionsx <= 4:
            color_set01 = [color2, color1] # color2 is being manipulated which is the BLUE
        elif singleconditionsx >= 5:
            color_set01 = [color1, color2] # colour1 is being manipulated which is the ORANGE
        cell_number = columns * rows
    
        num_color4 = int(np.floor(float(cell_number)*percent_color01)) # First colour
        num_color5 = int(np.floor(float(cell_number)*(1-percent_color01))) # Second colour
        
        # fill an array with colors. Each color should appear approximatively the same number of times.
        f_colors3 = []
        for i in range(num_color4):
            f_colors3.append(color_set01[0])
        for i in range(num_color5):
            f_colors3.append(color_set01[1])
        numpy.random.shuffle(color_set01)
        i = cell_number - len(f_colors3)
        while i > 0:
            f_colors3.append(color_set01[i])
            i -= 1
        
        # randomize color order.
        shuffle(f_colors3)
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys.append((x_left + c * square_size, y_top + l * square_size))
        
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys2 = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys2.append((x_left + c * square_size, y_top + l * square_size))
        
        # MAIN FUNCTION TO CREATE FIRST GRID
        flash01 = visual.ElementArrayStim(win=win,
                            fieldPos=position01,
                            fieldShape='sqr',
                            nElements=cell_number,
                            sizes=square_size,
                            xys=xys,
                            colors=f_colors3,
                            elementTex=None,
                            elementMask=None,
                            name='flash',
                            autoLog=False)
                            
                            
                            
    
    # flash stimulus change
    def flash_change():
        global flash01
        shuffle(flash01.colors)
        flash01.setColors(flash01.colors)
    
    # Time variables used during the experiment
    def set_timing():
        global f_t 
        f_t = 5 # The duration (in frame) of a flash image presentation
    
    # data_init
    set_colors()
    set_sizes()
    set_positions01()
    set_timing()
    
    #############################
    # MAIN FUNCTION HERE
    flash_init(win, fl_p3, square_size=0.3, columns=20, rows=20) # set the parameters here for the function!!
    #############################
    
    # Initialize components for Routine "show_flash"
    show_flashClock01 = core.Clock()
    frame_fl = visual.ImageStim(win=win, name='frame_fl',
        image=None, mask=None,
        ori=0, pos=fl_p3, size=f_s,
        color=f_c, colorSpace='rgb', opacity=1,
        flipHoriz=False, flipVert=False,
        texRes=128, interpolate=True, depth=0.0)
    
    # Create some handy timers
    globalClock01 = core.Clock()  # to track the time since experiment started
    routineTimer01 = core.CountdownTimer()  # to track time remaining of each (non-slip) routine 
    
    #------Prepare to start Routine "init_experiment"-------
    t = 0
    frameN = -1
    
    #------Prepare to start Routine "show_flash"-------
    t = 0
    show_flashClock01.reset()  # clock 
    frameN = -1
    # update component parameters for each repeat
    # flash begin routine
    f_change = 0
    
    # keep track of which components have finished
    show_flashComponents01 = []
    show_flashComponents01.append(frame_fl)
    for thisComponent in show_flashComponents01:
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    ########################################################################################
    ########################################################################################
    
    
    ########################################################################################
    # MAIN EXPERIMENT
    ########################################################################################
    
    # Put up the introduction text 
    if pcounter == 1:
        
        win.flip()
        practicetext1.draw()
        practicetext17.draw()
        win.flip()
        keypressed = event.waitKeys(timeStamped=False)
        checkclock01.reset()
                    
                    
    if pcounter == practicetrials+1:
        if colour_order1 == 1:
            win.flip()
            endspractice_b1.draw()
            endspractice_b2.draw()
            endspractice_bf.draw()
            win.flip()
        elif colour_order1 == 2:
            win.flip()
            endspractice_o1.draw()
            endspractice_o2.draw()
            endspractice_of.draw()
            win.flip()
            
        keypressed = event.waitKeys(timeStamped=False)
        checkclock01.reset()
    
    #---Start Routine "show_flash"-------
    continueRoutine = True
    while continueRoutine:
            
        # Hides mouse
        mouse = event.Mouse(visible=0)
        
        # get current time
        t = show_flashClock01.getTime()
        #print("t =", t)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        
        # update/draw components on each frame
        #print(frameN)
        
        # *frame_fl* updates
        if t >= 0.0 and frame_fl.status == NOT_STARTED:
            # keep track of start time/frame for later
            frame_fl.tStart = t  # underestimates by a little under one frame
            frame_fl.frameNStart = frameN  # exact frame index
            frame_fl.draw()
        # flash each frame
        if frameN >= f_change:
            flash_change()
            f_change += f_t
#        if colour_order1 == 1:
#            strialtextb.draw()
#        elif colour_order1 == 2:
            #strialtexto.draw()
        flash01.draw()  # First stimulus is drawn here
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineTimer01.reset()  # if we abort early the non-slip timer needs reset
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in show_flashComponents01:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        # PRACTICE TRIALS:
        if pcounter <= practicetrials:
            if event.getKeys(keyList=["z"]):
                pcounter = pcounter+1
                if singleconditionsx is 1 or singleconditionsx is 3 or singleconditionsx is 4:
                    win.flip()
                    correct_res.draw()
                    win.flip()
                    core.wait(1.5) # Keep the cross on screen for 2 seconds
                else:
                    win.flip()
                    incorrect_res.draw()
                    win.flip()
                    core.wait(1.5) # Keep the cross on screen for 2 seconds
                event.clearEvents(eventType='keyboard')
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock01.reset()
                event.clearEvents(eventType='keyboard')
                break
            elif event.getKeys(keyList=["m"]):
                pcounter = pcounter+1
                if singleconditionsx is 5 or singleconditionsx is 7 or singleconditionsx is 8:
                    win.flip()
                    correct_res.draw()
                    win.flip()
                    core.wait(1.5) # Keep the cross on screen for 2 seconds
                else:
                    win.flip()
                    incorrect_res.draw()
                    win.flip()
                    core.wait(1.5) # Keep the cross on screen for 2 seconds
                event.clearEvents(eventType='keyboard')
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock01.reset()
                event.clearEvents(eventType='keyboard')
                break
        # For experimental trials:
        elif pcounter > practicetrials:
            # RESPONSE 1:
            if event.getKeys(keyList=["escape"]):
                win.flip()
                breaktext.draw()
                win.flip()
                keypressed = event.waitKeys(timeStamped=False)
                checkclock01.reset()
            if event.getKeys(keyList=["6"]):
                win.close()
                core.quit()
            if event.getKeys(keyList=["z"]): # MORE key
            
                # Update practice trial counter
                pcounter = pcounter+1
                
                # print the condition we did
                print("actual single trial done =", singleconditionsx)
                
                # Track response times
                #rt = rtclock.getTime()
                time01 = checkclock01.getTime()
                RT.append(time01)
                
                if colour_order1 == 1:
                    if singleconditionsx <= 4:
                        correctresponse.append('1')
                        print('response ===========  correct')
                    elif singleconditionsx >= 5:
                        correctresponse.append('0')
                        print('response ===========  incorrect')
                elif colour_order1 == 2:
                    if singleconditionsx <= 4:
                        correctresponse.append('0')
                        print('response ===========  incorrect')
                    elif singleconditionsx >= 5:
                        correctresponse.append('1')
                        print('response ===========  correct')
                # Append which colour question was being asked:
                colourcolour1.append(colour_order1)
                
                # Keep track of keys pressed
                keyspressed.append('left')
                
                # Update the counter
                counter01 = counter01+1
                
                # Keep track of trial number to be saved 
                trialNo.append(counter01)
                
                
                # DRAW FIXATION CROSS AFTER EACH TRIAL
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock01.reset()
                event.clearEvents(eventType='keyboard')
                
                # END THE EXPERIMENT HERE AND SAVE DATA
                if counter01 == singletrials:
                    win.flip() # Clears the window
                    endtext01.draw() # Draw ending message here
                    endtext010.draw()
                    win.flip() # Clears the window
                    keypressed = event.waitKeys(timeStamped=False)
                break # End the expriment
                
             # RESPONSE 2: (Right Side)
            if event.getKeys(keyList=["m"]): # LESS key
                
                
                # Update practice trial counter
                pcounter = pcounter+1
                
                # print the condition we did
                print("actual single trial done =", singleconditionsx)
                
                time01 = checkclock01.getTime()
                RT.append(time01)
                
                if colour_order1 == 1:
                    if singleconditionsx <= 4:
                        correctresponse.append('0')
                        print('response ===========  incorrect')
                    elif singleconditionsx >= 5:
                        correctresponse.append('1')
                        print('response ===========  correct')
                elif colour_order1 == 2:
                    if singleconditionsx <= 4:
                        correctresponse.append('1')
                        print('response ===========  correct')
                    elif singleconditionsx >= 5:
                        correctresponse.append('0')
                        print('response ===========  incorrect')
                # Append which colour question was being asked:
                colourcolour1.append(colour_order1)
                
                # Keep track of keys pressed
                keyspressed.append('right')
                
                # Update the counter
                counter01 = counter01+1
                
                # Keep track of trial number to be saved 
                trialNo.append(counter01)
                
                
                # DRAW FIXATION CROSS AFTER EACH TRIAL
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock01.reset()
                event.clearEvents(eventType='keyboard')
                
                # END THE EXPERIMENT HERE AND SAVE DATA
                if counter01 == singletrials:
                    win.flip() # Clears the window
                    endtext01.draw() # Draw ending message here
                    endtext010.draw()
                    win.flip() # Clears the window
                    keypressed = event.waitKeys(timeStamped=False)
                break # End the expriment
            
            
            
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
        else:  # this Routine was not non-slip safe so reset non-slip timer
            routineTimer.reset()
        
        # END THE EXPERIMENT HERE
        if counter01 == singletrials:
            win.flip() # Clears the window
            endtext01.draw() # Draw ending message here
            endtext010.draw()
            win.flip() # Clears the window
            keypressed = event.waitKeys(timeStamped=False)
            break
            
#-------Ending Routine "show_flash"-------
for thisComponent in show_flashComponents01:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
########################################################################################
########################################################################################









########################################################################################
########################################################################################
########################################################################################
# Paired Grid Trials INTRODUCTION
########################################################################################
########################################################################################
########################################################################################
# Initialize components for Routine "init_experiment"
init_experimentClock = core.Clock()
# set_colors()
# Colors used during the experiment.s
def set_colors():
    global sc_c # screen color
    global f_c # frame color
    global sq_c # square color
    # 1 = white
    # -0.06 = grey 80
    # -0.37 = grey 120
    # -1 = black
    sc_c = 1
    f_c = -0.06
    sq_c = -0.37
    t_c = -0.06

# set_sizes()
# Sizes used during the experiment
def set_sizes():
    global f_s # frame size (square) (frame surrounding the stimulus)
    global sq_s # square size (square where the stimulus is shown)
    global l_s # line size (the width of the line surrounding the stimulus)
    f_s = 540
    sq_s = 800
    l_s = 100


########################################################################################
########################################################################################

########################################################################################
# Set main conditions and loop
########################################################################################
for i in range(1):
     
    p1=.35
    p2=.48

    leftside  = [-6,-5]
    rightside = [6,-5]
    
    
    # Set the position of left stimulus
    def set_positions():
        global fl_p # Where should the flash be drawn
        fl_p = leftside
            
    # Set the position of right stimulus
    def set_positions2():
        global fl_p2 # Where should the flash be drawn
        fl_p2 = rightside
        
    # flash stimulus functions
    # flash initialization
    def flash_init(win, position=[0,0], position2=[0,0], square_size=10, columns=20, rows=20, percent_color1=p1, percent_color2=p2): # Colour 1 being manipulated
        global flash # The flash stimulus (an array of flashing squares)
        global flash2

        color_set = [color2, color1]   # Orange
        color_set2 = [color2, color1]  # Orange
        cell_number = columns * rows
    
        num_color1 = int(np.floor(float(cell_number)*percent_color1)) # First colour
        num_color2 = int(np.floor(float(cell_number)*(1-percent_color1))) # Second f
    
        num_color3 = int(np.floor(float(cell_number)*percent_color2)) # First colour
        num_color4 = int(np.floor(float(cell_number)*(1-percent_color2))) # Second f
        
        #print(cell_number,num_color1,num_color2)
        
        # fill an array with colors. Each color should appear approximatively the same number of times.
        f_colors = []
        for i in range(num_color1):
            f_colors.append(color_set[0])
        for i in range(num_color2):
            f_colors.append(color_set[1])
        numpy.random.shuffle(color_set)
        i = cell_number - len(f_colors)
        while i > 0:
            f_colors.append(color_set[i])
            i -= 1
        
        f_colors2 = []
        for i in range(num_color3):
            f_colors2.append(color_set2[0])
        for i in range(num_color4):
            f_colors2.append(color_set2[1])
        numpy.random.shuffle(color_set2)
        i = cell_number - len(f_colors2)
        while i > 0:
            f_colors2.append(color_set2[i])
            i -= 1
        
        # randomize color order.
        shuffle(f_colors)
        shuffle(f_colors2)
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys.append((x_left + c * square_size, y_top + l * square_size))
        
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys2 = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys2.append((x_left + c * square_size, y_top + l * square_size))
        
        # MAIN FUNCTION TO CREATE FIRST GRID
        flash = visual.ElementArrayStim(win=win,
                            fieldPos=position,
                            fieldShape='sqr',
                            nElements=cell_number,
                            sizes=square_size,
                            xys=xys,
                            colors=f_colors,
                            elementTex=None,
                            elementMask=None,
                            name='flash',
                            autoLog=False)
                            
        # MAIN FUNCTION TO CREATE SECOND GRID
        flash2 = visual.ElementArrayStim(win=win,
                        fieldPos=position2,
                        fieldShape='sqr',
                        nElements=cell_number,
                        sizes=square_size,
                        xys=xys2,
                        colors=f_colors2,
                        elementTex=None,
                        elementMask=None,
                        name='flash',
                        autoLog=False)
                            
                            
    
    # flash stimulus change
    def flash_change():
        global flash
        shuffle(flash.colors)
        flash.setColors(flash.colors)
    
    def flash2_change():
        global flash2
        shuffle(flash2.colors)
        flash2.setColors(flash2.colors)
    
    # Time variables used during the experiment
    def set_timing():
        global f_t 
        f_t = 5 # The duration (in frame) of a flash image presentation
    
    # data_init
    set_colors()
    set_sizes()
    set_positions()
    set_positions2()
    set_timing()
    
    #############################
    # MAIN FUNCTION HERE
    flash_init(win, fl_p, fl_p2, square_size=0.3, columns=20, rows=20) # set the parameters here for the function!!
    #############################
    
    # Initialize components for Routine "show_flash"
    show_flashClock = core.Clock()
    frame_fl = visual.ImageStim(win=win, name='frame_fl',
        image=None, mask=None,
        ori=0, pos=fl_p, size=f_s,
        color=f_c, colorSpace='rgb', opacity=1,
        flipHoriz=False, flipVert=False,
        texRes=128, interpolate=True, depth=0.0)
    
    # Create some handy timers
    globalClock = core.Clock()  # to track the time since experiment started
    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine 
    
    #------Prepare to start Routine "init_experiment"-------
    t = 0
    frameN = -1
    
    #------Prepare to start Routine "show_flash"-------
    t = 0
    show_flashClock.reset()  # clock 
    frameN = -1
    # update component parameters for each repeat
    # flash begin routine
    f_change = 0
    
    # keep track of which components have finished
    show_flashComponents = []
    show_flashComponents.append(frame_fl)
    for thisComponent in show_flashComponents:
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    ########################################################################################
    ########################################################################################

    #---Start Routine "show_flash"-------
    continueRoutine = True
    while continueRoutine:
        # Hides mouse
        mouse = event.Mouse(visible=0)
        
        # get current time
        t = show_flashClock.getTime()
        #print("t =", t)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        
        # update/draw components on each frame
        #print(frameN)
        
        # *frame_fl* updates
        if t >= 0.0 and frame_fl.status == NOT_STARTED:
            # keep track of start time/frame for later
            frame_fl.tStart = t  # underestimates by a little under one frame
            frame_fl.frameNStart = frameN  # exact frame index
            frame_fl.draw()
        # flash each frame
        if frameN >= f_change:
            flash_change()
            flash2_change()
            f_change += f_t
        
        section2practice22i.draw() # Draw ending message here
        section2practice22ii.draw() # Draw ending message here
        section2practice22iii.draw() # Draw ending message here
        section2practice22iiii.draw() # Draw ending message here
        flash.draw()  # First stimulus is drawn here
        flash2.draw() # Second stimulus is drawn here
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineTimer.reset()  # if we abort early the non-slip timer needs reset
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in show_flashComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        if event.getKeys(keyList=["space"]):
            break
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
        else:  # this Routine was not non-slip safe so reset non-slip timer
            routineTimer.reset()
            
#-------Ending Routine "show_flash"-------
for thisComponent in show_flashComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
        
win.flip()
practicetext1q.draw()
practicetext1qq.draw()
win.flip()
keypressed = event.waitKeys(timeStamped=False)
########################################################################################
########################################################################################









########################################################################################
########################################################################################
########################################################################################
# Paired Grid Trials - First Block:
########################################################################################
########################################################################################
########################################################################################
# Initialize components for Routine "init_experiment"
init_experimentClock = core.Clock()
# set_colors()
# Colors used during the experiment.s
def set_colors():
    global sc_c # screen color
    global f_c # frame color
    global sq_c # square color
    # 1 = white
    # -0.06 = grey 80
    # -0.37 = grey 120
    # -1 = black
    sc_c = 1
    f_c = -0.06
    sq_c = -0.37
    t_c = -0.06

# set_sizes()
# Sizes used during the experiment
def set_sizes():
    global f_s # frame size (square) (frame surrounding the stimulus)
    global sq_s # square size (square where the stimulus is shown)
    global l_s # line size (the width of the line surrounding the stimulus)
    f_s = 540
    sq_s = 800
    l_s = 100

########################################################################################
# Set conditions
########################################################################################
# Define conditions:
pairedconditionsB1 = []

for i in range(13):
    # CLOSE experimental trials:
    pairedconditionsB1.append(1)
    pairedconditionsB1.append(2)
    pairedconditionsB1.append(3)
    pairedconditionsB1.append(4)
    pairedconditionsB1.append(5)
    pairedconditionsB1.append(6)
    pairedconditionsB1.append(7)
    pairedconditionsB1.append(8)
    pairedconditionsB1.append(9)
    pairedconditionsB1.append(10)
    pairedconditionsB1.append(11)
    pairedconditionsB1.append(12)
    pairedconditionsB1.append(13)
    pairedconditionsB1.append(14)
    pairedconditionsB1.append(15)
    pairedconditionsB1.append(16)

# Conditions for practice trials 
pairedconditionsB1xx = [91,92,93,94,95,96]
np.random.shuffle(pairedconditionsB1xx) # Randomly shuffle paired grid practice trials

# Randomly shuffle all the conditions
np.random.shuffle(pairedconditionsB1)

########################################################################################
########################################################################################

########################################################################################
# Set main conditions and loop
########################################################################################

# Counter to keep track of things
counter = 0
thecount = 0
ycounter = 1
supercounter = 0
break_count = 0
nowbreak = 1
pcounter2 = 1

xcounter = 0

# Begin main trial loop here:
for j in range(pairedtrials_total): 
    
    if ycounter > 6:
        pcounter2 = 2
    print('pcounter2 ==================', pcounter2)
    
    if pcounter2 == 1:
        pairedconditionsx = pairedconditionsB1xx[j] # Select what condition is to be performed on practice trial
        colour = 2
    elif pcounter > 1:
        # Set the colour order for the first colour block:
        colour_order1 = colour_order[0]
        pairedconditionsx = pairedconditionsB1[xcounter] # CLOSE block with experimental and control block
    
        
    # Set the conditions here:
    #############################################
    # The paired grid trials:
    #############################################
    
    if colour_order1 == 1: # IF THE QUESTION IS MORE BLUE:
        # E,E: (BB) Level 1 & 2:
        if pairedconditionsx == 1:
            colour = colour_order1
            p1 = .65
            p2 = .65
        elif pairedconditionsx == 2:
            colour = colour_order1
            p1 = .60
            p2 = .60
            
        # E,E: (OB) Level 1 & 2:
        elif pairedconditionsx == 3:
            colour = colour_order1
            p1=.35
            p2=.65
        elif pairedconditionsx == 4:
            colour = colour_order1
            p1=.40
            p2=.60
        
        # H,H: (bb) level 1 & 2:
        elif pairedconditionsx == 5:
            colour= colour_order1
            p1=.54
            p2=.54
        elif pairedconditionsx == 6:
            colour= colour_order1
            p1=.52
            p2=.52
        
        # H,H: (ob) level 1 & 2:
        elif pairedconditionsx == 7:
            colour= colour_order1
            p1=.46
            p2=.54
        elif pairedconditionsx == 8:
            colour= colour_order1
            p1=.48
            p2=.52
        
        # H,E: (bB) level 1 & 2:
        if pairedconditionsx == 9:
            colour = colour_order1
            p1 = .54
            p2 = .65
        elif pairedconditionsx == 10:
            colour = colour_order1
            p1 = .52
            p2 = .60
            
        # H,E: (oB) level 1 & 2:
        elif pairedconditionsx == 11:
            colour = colour_order1
            p1=.46
            p2=.65
        elif pairedconditionsx == 12:
            colour = colour_order1
            p1=.48
            p2=.60
        
        # E,H: (Bo) level 1 & 2:
        elif pairedconditionsx == 13:
            colour= colour_order1
            p1=.65
            p2=.46
        elif pairedconditionsx == 14:
            colour= colour_order1
            p1=.60
            p2=.48
        
        # E,H: (Bb) level 1 & 2:
        elif pairedconditionsx == 15:
            colour= colour_order1
            p1=.65
            p2=.54
        elif pairedconditionsx == 16:
            colour= colour_order1
            p1=.60
            p2=.52
            
    if colour_order1 == 2: # IF THE QUESTION IS MORE ORANGE:
        # E,E: (BO) level 1 & 2:
        if pairedconditionsx == 1:
            colour = colour_order1
            p1 = .35
            p2 = .65
        elif pairedconditionsx == 2:
            colour = colour_order1
            p1 = .40
            p2 = .60
            
        # E,E: (OO) level 1 & 2:
        elif pairedconditionsx == 3:
            colour = colour_order1
            p1=.65
            p2=.65
        elif pairedconditionsx == 4:
            colour = colour_order1
            p1=.60
            p2=.60
        
        # H,H: (bo) level 1 & 2:
        elif pairedconditionsx == 5:
            colour= colour_order1
            p1=.46
            p2=.54
        elif pairedconditionsx == 6:
            colour= colour_order1
            p1=.48
            p2=.52
        
        # H,H: (oo) level 1 & 2:
        elif pairedconditionsx == 7:
            colour= colour_order1
            p1=.54
            p2=.54
        elif pairedconditionsx == 8:
            colour= colour_order1
            p1=.52
            p2=.52
        
        # H,E: (bO) level 1 & 2 :
        if pairedconditionsx == 9:
            colour = colour_order1
            p1 = .46
            p2 = .65
        elif pairedconditionsx == 10:
            colour = colour_order1
            p1 = .48
            p2 = .60
            
        # H,E: (oO) level 1 & 2:
        elif pairedconditionsx == 11:
            colour = colour_order1
            p1=.54
            p2=.65
        elif pairedconditionsx == 12:
            colour = colour_order1
            p1=.52
            p2=.60
        
        # E,H: (Ob) level 1 & 2:
        elif pairedconditionsx == 13:
            colour= colour_order1
            p1=.65
            p2=.46
        elif pairedconditionsx == 14:
            colour= colour_order1
            p1=.60
            p2=.48
        
        # E,H: (Oo) level 1 & 2:
        elif pairedconditionsx == 15:
            colour= colour_order1
            p1=.65
            p2=.54
        elif pairedconditionsx == 16:
            colour= colour_order1
            p1=.60
            p2=.52
    
    
    #############################################
    #############################################
    
    #############################################
    # Practice trial conditions:
    #############################################
    # EE:
    if pairedconditionsx == 91:
        p1 = .65 # orange
        p2 = .60 # orange
        leftside  = [-8.5,0]
        rightside = [8.5,0]
    elif pairedconditionsx == 92:
        p1 = .40 # orange
        p2 = .35 # orange
        leftside  = [-8.5,0]
        rightside = [8.5,0]
    # HE:
    elif pairedconditionsx == 93:
        p1=.48 # orange
        p2=.65 # orange
        leftside  = [-8.5,0]
        rightside = [8.5,0]
    elif pairedconditionsx == 94:
        p1=.52 # orange
        p2=.65 # orange
        leftside  = [-8.5,0]
        rightside = [8.5,0]
    # EH:
    elif pairedconditionsx == 95:
        p1=.60 # Orange
        p2=.54 # Orange
        leftside  = [-8.5,0]
        rightside = [8.5,0]
    elif pairedconditionsx == 96:
        p1=.60 # orange
        p2=.46 # orange
        leftside  = [-8.5,0]
        rightside = [8.5,0]
    #############################################
    #############################################
    
    
    # Collecting the condition we are on:
    if  pcounter2 > 1:
        # Append the condition and the probabilities given:
        if colour_order1 == 1: # If colour is Blue
            if pairedconditionsx == 1:
                conused2.append('B1,B1')
                difflevel2.append('Exp - Easy 1 & Easy 1')
            elif pairedconditionsx == 2:
                conused2.append('B2,B2')
                difflevel2.append('Exp - Easy 2 & Easy 2')
            elif pairedconditionsx == 3:
                conused2.append('O1,B1')
                difflevel2.append('Exp - Easy 1 & Easy 1')
            elif pairedconditionsx == 4:
                conused2.append('O2,B2')
                difflevel2.append('Exp - Easy 2 & Easy 2')
            elif pairedconditionsx == 5:
                conused2.append('b1,b1')
                difflevel2.append('Exp - Hard 1 & Hard 1')
            elif pairedconditionsx == 6:
                conused2.append('b2,b2')
                difflevel2.append('Exp - Hard 2 & Hard 2')
            elif pairedconditionsx == 7:
                conused2.append('o1,b1')
                difflevel2.append('Exp - Hard 1 & Hard 1')
            elif pairedconditionsx == 8:
                conused2.append('o2,b2')
                difflevel2.append('Exp - Hard 2 & Hard 2')
            elif pairedconditionsx == 9:
                conused2.append('b1,B1')
                difflevel2.append('Con - Hard 1 & Easy 1')
            elif pairedconditionsx == 10:
                conused2.append('b2,B2')
                difflevel2.append('Con - Hard 2 & Easy 2')
            elif pairedconditionsx == 11:
                conused2.append('o1,B1')
                difflevel2.append('Con - Hard 1 & Easy 1')
            elif pairedconditionsx == 12:
                conused2.append('o2,B2')
                difflevel2.append('Con - Hard 2 & Easy 2')
            elif pairedconditionsx == 13:
                conused2.append('B1,o1')
                difflevel2.append('Con - Easy 1 & Hard 1')
            elif pairedconditionsx == 14:
                conused2.append('B2,o2')
                difflevel2.append('Con - Easy 2 & Hard 2')
            elif pairedconditionsx == 15:
                conused2.append('B1,b1')
                difflevel2.append('Con - Easy 1 & Hard 1')
            elif pairedconditionsx == 16:
                conused2.append('B2,b2')
                difflevel2.append('Con - Easy 2 & Hard 2')
                
                
        elif colour_order1 == 2: # If colour is Orange
            if pairedconditionsx == 1:
                conused2.append('B1,O1')
                difflevel2.append('Exp - Easy 1 & Easy 1')
            elif pairedconditionsx == 2:
                conused2.append('B2,O2')
                difflevel2.append('Exp - Easy 2 & Easy 2')
            elif pairedconditionsx == 3:
                conused2.append('O1,O1')
                difflevel2.append('Exp - Easy 1 & Easy 1')
            elif pairedconditionsx == 4:
                conused2.append('O2,O2')
                difflevel2.append('Exp - Easy 2 & Easy 2')
            elif pairedconditionsx == 5:
                conused2.append('b1,o1')
                difflevel2.append('Exp - Hard 1 & Hard 1')
            elif pairedconditionsx == 6:
                conused2.append('b2,o2')
                difflevel2.append('Exp - Hard 2 & Hard 2')
            elif pairedconditionsx == 7:
                conused2.append('o1,o1')
                difflevel2.append('Exp - Hard 1 & Hard 1')
            elif pairedconditionsx == 8:
                conused2.append('o2,o2')
                difflevel2.append('Exp - Hard 2 & Hard 2')
            elif pairedconditionsx == 9:
                conused2.append('O1,b1')
                difflevel2.append('Con - Easy 1 & Hard 1')
            elif pairedconditionsx == 10:
                conused2.append('O2,b2')
                difflevel2.append('Con - Easy 2 & Hard 2')
            elif pairedconditionsx == 11:
                conused2.append('O1,o1')
                difflevel2.append('Con - Easy 1 & Hard 1')
            elif pairedconditionsx == 12:
                conused2.append('O2,o2')
                difflevel2.append('Exp - Easy 2 & Hard 2')
            elif pairedconditionsx == 13:
                conused2.append('b1,O1')
                difflevel2.append('Con - Hard 1 & Easy 1')
            elif pairedconditionsx == 14:
                conused2.append('b2,O2')
                difflevel2.append('Con - Hard 2 & Easy 2')
            elif pairedconditionsx == 15:
                conused2.append('o1,O1')
                difflevel2.append('Con - Hard 1 & Easy 1')
            elif pairedconditionsx == 16:
                conused2.append('o2,O2')
                difflevel2.append('Con - Hard 2 & Easy 2')
                
                
                
                
    print('condition ================', pairedconditionsx)
    print('colour_order1 ==========', colour_order1)
    print('colour ==================', colour)
    print('p1 ====================', p1)
    print('p2 ====================', p2)
    
    
    
    #############################################
    #############################################
    # Set the distances for the stimuli
    #############################################
    #############################################
    if 1 <= pairedconditionsx <= 16:
        leftside  = [-8.5,0]
        rightside = [8.5,0]
    #############################################
    #############################################
    
    
    # Set the position of left stimulus
    def set_positions():
        global fl_p # Where should the flash be drawn
        fl_p = leftside
            
    # Set the position of right stimulus
    def set_positions2():
        global fl_p2 # Where should the flash be drawn
        fl_p2 = rightside
        
    # flash stimulus functions
    # flash initialization
    def flash_init(win, position=[0,0], position2=[0,0], square_size=10, columns=20, rows=20, percent_color1=p1, percent_color2=p2): # Colour 1 being manipulated
        global flash # The flash stimulus (an array of flashing squares)
        global flash2
        
        if colour == 1:
            color_set = [color2, color1]   # Blue
            color_set2 = [color2, color1]  # Blue
        elif colour == 2:
            color_set = [color1, color2]   # Orange
            color_set2 = [color1, color2]  # Orange
        cell_number = columns * rows
    
        num_color1 = int(np.floor(float(cell_number)*percent_color1)) # First colour
        num_color2 = int(np.floor(float(cell_number)*(1-percent_color1))) # Second colour
    
        num_color3 = int(np.floor(float(cell_number)*percent_color2)) # First colour
        num_color4 = int(np.floor(float(cell_number)*(1-percent_color2))) # Second colour
        
        # fill an array with colors. Each color should appear approximatively the same number of times.
        f_colors = []
        for i in range(num_color1):
            f_colors.append(color_set[0])
        for i in range(num_color2):
            f_colors.append(color_set[1])
        numpy.random.shuffle(color_set)
        i = cell_number - len(f_colors)
        while i > 0:
            f_colors.append(color_set[i])
            i -= 1
        
        f_colors2 = []
        for i in range(num_color3):
            f_colors2.append(color_set2[0])
        for i in range(num_color4):
            f_colors2.append(color_set2[1])
        numpy.random.shuffle(color_set2)
        i = cell_number - len(f_colors2)
        while i > 0:
            f_colors2.append(color_set2[i])
            i -= 1
        
        # randomize color order.
        shuffle(f_colors)
        shuffle(f_colors2)
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys.append((x_left + c * square_size, y_top + l * square_size))
        
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys2 = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys2.append((x_left + c * square_size, y_top + l * square_size))
        
        # MAIN FUNCTION TO CREATE FIRST GRID
        flash = visual.ElementArrayStim(win=win,
                            fieldPos=position,
                            fieldShape='sqr',
                            nElements=cell_number,
                            sizes=square_size,
                            xys=xys,
                            colors=f_colors,
                            elementTex=None,
                            elementMask=None,
                            name='flash',
                            autoLog=False)
                            
        # MAIN FUNCTION TO CREATE SECOND GRID
        flash2 = visual.ElementArrayStim(win=win,
                        fieldPos=position2,
                        fieldShape='sqr',
                        nElements=cell_number,
                        sizes=square_size,
                        xys=xys2,
                        colors=f_colors2,
                        elementTex=None,
                        elementMask=None,
                        name='flash',
                        autoLog=False)
                            
                            
    
    # flash stimulus change
    def flash_change():
        global flash
        shuffle(flash.colors)
        flash.setColors(flash.colors)
    
    def flash2_change():
        global flash2
        shuffle(flash2.colors)
        flash2.setColors(flash2.colors)
    
    # Time variables used during the experiment
    def set_timing():
        global f_t 
        f_t = 5 # The duration (in frame) of a flash image presentation
    
    # data_init
    set_colors()
    set_sizes()
    set_positions()
    set_positions2()
    set_timing()
    
    #############################
    # MAIN FUNCTION HERE
    flash_init(win, fl_p, fl_p2, square_size=0.3, columns=20, rows=20) # set the parameters here for the function!!
    #############################
    
    # Initialize components for Routine "show_flash"
    show_flashClock = core.Clock()
    frame_fl = visual.ImageStim(win=win, name='frame_fl',
        image=None, mask=None,
        ori=0, pos=fl_p, size=f_s,
        color=f_c, colorSpace='rgb', opacity=1,
        flipHoriz=False, flipVert=False,
        texRes=128, interpolate=True, depth=0.0)
    
    # Create some handy timers
    globalClock = core.Clock()  # to track the time since experiment started
    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine 
    
    #------Prepare to start Routine "init_experiment"-------
    t = 0
    frameN = -1
    
    #------Prepare to start Routine "show_flash"-------
    t = 0
    show_flashClock.reset()  # clock 
    frameN = -1
    # update component parameters for each repeat
    # flash begin routine
    f_change = 0
    
    # keep track of which components have finished
    show_flashComponents = []
    show_flashComponents.append(frame_fl)
    for thisComponent in show_flashComponents:
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    ########################################################################################
    ########################################################################################
    
    
    ########################################################################################
    # MAIN EXPERIMENT
    ########################################################################################
    
    if ycounter == practicetrials+1:
        win.flip()
        endspractice2.draw()
        endspractice20.draw()
        win.flip()
        keypressed = event.waitKeys(timeStamped=False)
        checkclock.reset()
        
    # If P's are doing experimental trials then have introduction text at the start of each block:
    if ycounter == practicetrials+1:
        if colour_order1 == 1:
            win.flip()
            blockfourthtext.draw()
            blockonetext150.draw()
            win.flip()
            keypressed = event.waitKeys(timeStamped=False)
            checkclock.reset()
        elif colour_order1 == 2:
            win.flip()
            blocktwotext.draw()
            blockonetext150.draw()
            win.flip()
            keypressed = event.waitKeys(timeStamped=False)
            checkclock.reset()
            
            
            
    #---Start Routine "show_flash"-------
    continueRoutine = True
    while continueRoutine:
            
        # Hides mouse
        mouse = event.Mouse(visible=0)
        
        # get current time
        t = show_flashClock.getTime()
        #print("t =", t)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        
        # *frame_fl* updates
        if t >= 0.0 and frame_fl.status == NOT_STARTED:
            # keep track of start time/frame for later
            frame_fl.tStart = t  # underestimates by a little under one frame
            frame_fl.frameNStart = frameN  # exact frame index
            frame_fl.draw()
        # flash each frame
        if frameN >= f_change:
            flash_change()
            flash2_change()
            f_change += f_t
            
        flash.draw()  # First stimulus is drawn here
        flash2.draw() # Second stimulus is drawn here
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineTimer.reset()  # if we abort early the non-slip timer needs reset
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in show_flashComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        
        
        if ycounter <= practicetrials:
            if event.getKeys(keyList=["z"]):
                # Update the ycounter:
                ycounter = ycounter+1 
                if pairedconditionsx is 91 or pairedconditionsx is 94 or pairedconditionsx is 95:
                    win.flip()
                    correct_res.draw()
                    win.flip()
                    core.wait(2.0)
                else:
                    win.flip()
                    incorrect_res.draw()
                    win.flip()
                    core.wait(2.0)
                event.clearEvents(eventType='keyboard')
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock.reset()
                event.clearEvents(eventType='keyboard')
                break
            elif event.getKeys(keyList=["m"]):
                # Update the ycounter:
                ycounter = ycounter+1
                if pairedconditionsx is 92 or pairedconditionsx is 93 or pairedconditionsx is 96:
                    win.flip()
                    correct_res.draw()
                    win.flip()
                    core.wait(2.0)
                else:
                    win.flip()
                    incorrect_res.draw()
                    win.flip()
                    core.wait(2.0)
                event.clearEvents(eventType='keyboard')
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock.reset()
                event.clearEvents(eventType='keyboard')
                break
        # Experimental trials:
        elif ycounter > practicetrials:
            if event.getKeys(keyList=["escape"]):
                win.flip()
                breaktext.draw()
                win.flip()
                keypressed = event.waitKeys(timeStamped=False)
                checkclock.reset()
            if event.getKeys(keyList=["6"]):
                win.close()
                core.quit()
            # RESPONSE 1: (Left Side)
            if event.getKeys(keyList=["z"]): # MORE OF A COLOUR
                
                # Update the ycounter
                ycounter = ycounter+1
                
                # Update the xcounter:
                xcounter = xcounter+1
                
                # Collect correct/incorrect responses
                if colour_order1 == 1: # If question is more     
                    if pairedconditionsx is 1 or pairedconditionsx is 3 or pairedconditionsx is 5 or pairedconditionsx is 6 or pairedconditionsx is 9 or pairedconditionsx is 10 or pairedconditionsx is 15 or pairedconditionsx is 16:
                        correctresponse2.append('1')
                    else:
                        correctresponse2.append('0')
                elif colour_order1 == 2:
                    if pairedconditionsx is 3 or pairedconditionsx is 4 or pairedconditionsx is 7 or pairedconditionsx is 8 or pairedconditionsx is 11 or pairedconditionsx is 12 or pairedconditionsx is 15 or pairedconditionsx is 16:
                        correctresponse2.append('1')
                    else:
                        correctresponse2.append('0')
                
                # Keep track of keys pressed
                keyspressed2.append('left')
                
                # Update the counters:
                counter = counter+1
                
                # Keep track of trial number to be saved 
                trialNo2.append(counter)
                
                time2 = checkclock.getTime()
                RT2.append(time2)
                
                # DRAW FIXATION CROSS AFTER EACH TRIAL
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock.reset()
                event.clearEvents(eventType='keyboard')
                
                # END THE EXPERIMENT HERE
                if counter == pairedtrials:
                    win.flip() # Clears the window
                    endtext.draw() # Draw ending message here
                    win.flip() # Clears the window
                    core.wait(5.0)
                    win.flip()
                break
                
             # RESPONSE 2: (Right Side)
            if event.getKeys(keyList=["m"]): # LESS OF A COLOUR
                
                # Update the ycounter
                ycounter = ycounter+1
                
                # Update the ycounter:
                xcounter = xcounter+1
                
                # Collect correct/incorrect responses
                if colour_order1 == 1: # If question is more     
                    if pairedconditionsx is 3 or pairedconditionsx is 4 or pairedconditionsx is 7 or pairedconditionsx is 8 or pairedconditionsx is 11 or pairedconditionsx is 12 or pairedconditionsx is 13 or pairedconditionsx is 14:
                        correctresponse2.append('1')
                    else:
                        correctresponse2.append('0')
                elif colour_order1 == 2:
                    if pairedconditionsx is 1 or pairedconditionsx is 2 or pairedconditionsx is 5 or pairedconditionsx is 6 or pairedconditionsx is 9 or pairedconditionsx is 10 or pairedconditionsx is 13 or pairedconditionsx is 14:
                        correctresponse2.append('1')
                    else:
                        correctresponse2.append('0')
                    
                # Keep track of keys pressed
                keyspressed2.append('right')
                
                # Update the counter
                counter = counter+1
                
                # Keep track of trial number to be saved 
                trialNo2.append(counter)
                
                time2 = checkclock.getTime()
                RT2.append(time2)
                
                # DRAW FIXATION CROSS AFTER EACH TRIAL
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock.reset()
                event.clearEvents(eventType='keyboard')
                
                # END THE EXPERIMENT HERE
                if counter == pairedtrials:
                    win.flip() # Clears the window
                    endtext.draw() # Draw ending message here
                    win.flip() # Clears the window
                    core.wait(5.0)
                    win.flip()
                break
                      
                
         
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
        else:  # this Routine was not non-slip safe so reset non-slip timer
            routineTimer.reset()
        
    
        
#-------Ending Routine "show_flash"-------
for thisComponent in show_flashComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
########################################################################################
########################################################################################







# Set the colour order for the first colour block:
colour_order1 = colour_order[1]

if colour_order1 == 2:
    introtext0122o.draw()
    introtext0122oo.draw()
    win.flip()
    keypressed = event.waitKeys(timeStamped=False)
elif colour_order1 == 1:
    introtext0122b.draw()
    introtext0122bb.draw()
    win.flip()
    keypressed = event.waitKeys(timeStamped=False)
checkclock01s2.reset()

# Shuffle the single trial conditions again:
np.random.shuffle(singleconditions_all)







########################################################################################
########################################################################################
########################################################################################
# Single Grid Trials - Second Block
########################################################################################
########################################################################################
########################################################################################
# Initialize components for Routine "init_experiment"
init_experimentClock = core.Clock()
# set_colors()
# Colors used during the experiment.s
def set_colors():
    global sc_c # screen color
    global f_c # frame color
    global sq_c # square color
    # 1 = white
    # -0.06 = grey 80
    # -0.37 = grey 120
    # -1 = black
    sc_c = 1
    f_c = -0.06
    sq_c = -0.37
    t_c = -0.06

# set_sizes()
# Sizes used during the experiment
def set_sizes():
    global f_s # frame size (square) (frame surrounding the stimulus)
    global sq_s # square size (square where the stimulus is shown)
    global l_s # line size (the width of the line surrounding the stimulus)
    f_s = 540
    sq_s = 800
    l_s = 100
    
# Set the position of left stimulus
def set_positions01():
    global fl_p3 # Where should the flash be drawn
    fl_p3 = [0, 0]

########################################################################################
# Set main conditions and loop
########################################################################################

# Counter to keep track of things
counters2 = 0
thecounts2 = 0
counter01s2 = 0
thecount01s2 = 0
pcounters2 = practicetrials+1
pcounter2s2 = 1


for j in range(singletrials):
    # Select what condition is to be performed on experimental trials:
    if colour_order1 == 1:
        singleconditionsx = singleconditions_all[counter01s2]
    elif colour_order1 == 2:
        singleconditionsx = singleconditions_all[counter01s2]
        
    
#    if pcounters2 > practicetrials:
        # Append the condition we're on:
    if singleconditionsx == 1:
        conused3.append('b,o')
        difflevel3.append('Exp - Hard 1')
    elif singleconditionsx == 2:
        conused3.append('b,o')
        difflevel3.append('Exp - Hard 2')
    elif singleconditionsx == 3:
        conused3.append('B,o')
        difflevel3.append('Con - Easy 1')
    elif singleconditionsx == 4:
        conused3.append('B,o')
        difflevel3.append('Con - Easy 2')
    elif singleconditionsx == 5:
        conused3.append('o,b')
        difflevel3.append('Exp - Hard 1')
    elif singleconditionsx == 6:
        conused3.append('o,b')
        difflevel3.append('Exp - Hard 2')
    elif singleconditionsx == 7:
        conused3.append('O,b')
        difflevel3.append('Con - Easy 1')
    elif singleconditionsx == 8:
        conused3.append('O,b')
        difflevel3.append('Con - Easy 2')
    
    # Set the conditions here:
    # BLUE colours:
    if singleconditionsx == 1:
        p01 = .52#(48/52)
    elif singleconditionsx == 2:
        p01 = .54#(46/54)
    elif singleconditionsx == 3:
        p01 = .60#(60/40)
    elif singleconditionsx == 4:
        p01 = .65#(65/35)
        
    # Orange colours:
    elif singleconditionsx == 5:
        p01 = .52#(48/52)
    elif singleconditionsx == 6:
        p01 = .54#(46/54)
    elif singleconditionsx == 7:
        p01 = .60#(60/40)
    elif singleconditionsx == 8:
        p01 = .65#(65/35)
        
        
    print('condition ======================', singleconditionsx)
    print('Colour ======================', colour_order1)
    print('p01 ======================', p01)
    
    # flash stimulus functions
    # flash initialization
    def flash_init(win, position01=[0,0], square_size=10, columns=20, rows=20, percent_color01=p01): # Colour2 being manipulated whic is BLUE
        global flash01s2 # The flash stimulus (an array of flashing squares)
        
        if singleconditionsx <= 4:
            color_set01 = [color2, color1] # color2 being manipulated which is the BLUE
        elif singleconditionsx >= 5:
            color_set01 = [color1, color2] # colour1 is being manipulated which is the ORANGE
        cell_number = columns * rows
    
        num_color4 = int(np.floor(float(cell_number)*percent_color01)) # First colour
        num_color5 = int(np.floor(float(cell_number)*(1-percent_color01))) # Second colour
        
        # fill an array with colors. Each color should appear approximatively the same number of times.
        f_colors3s2 = []
        for i in range(num_color4):
            f_colors3s2.append(color_set01[0])
        for i in range(num_color5):
            f_colors3s2.append(color_set01[1])
        numpy.random.shuffle(color_set01)
        i = cell_number - len(f_colors3s2)
        while i > 0:
            f_colors3s2.append(color_set01[i])
            i -= 1
        
        # randomize color order.
        shuffle(f_colors3s2)
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys.append((x_left + c * square_size, y_top + l * square_size))
        
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys2 = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys2.append((x_left + c * square_size, y_top + l * square_size))
        
        # MAIN FUNCTION TO CREATE FIRST GRID
        flash01s2 = visual.ElementArrayStim(win=win,
                            fieldPos=position01,
                            fieldShape='sqr',
                            nElements=cell_number,
                            sizes=square_size,
                            xys=xys,
                            colors=f_colors3s2,
                            elementTex=None,
                            elementMask=None,
                            name='flash',
                            autoLog=False)
                            
                            
                            
    
    # flash stimulus change
    def flash_changes2():
        global flash01s2
        shuffle(flash01s2.colors)
        flash01s2.setColors(flash01s2.colors)
    
    # Time variables used during the experiment
    def set_timings2():
        global f_t 
        f_t = 5 # The duration (in frame) of a flash image presentation
    
    # data_init
    set_colors()
    set_sizes()
    set_positions01()
    set_timing()
    
    #############################
    # MAIN FUNCTION HERE
    flash_init(win, fl_p3, square_size=0.3, columns=20, rows=20) # set the parameters here for the function!!
    #############################
    
    # Initialize components for Routine "show_flash"
    show_flashClock01s2 = core.Clock()
    frame_fl = visual.ImageStim(win=win, name='frame_fl',
        image=None, mask=None,
        ori=0, pos=fl_p3, size=f_s,
        color=f_c, colorSpace='rgb', opacity=1,
        flipHoriz=False, flipVert=False,
        texRes=128, interpolate=True, depth=0.0)
    
    # Create some handy timers
    globalClock01s2 = core.Clock()  # to track the time since experiment started
    routineTimer01s2 = core.CountdownTimer()  # to track time remaining of each (non-slip) routine 
    
    #------Prepare to start Routine "init_experiment"-------
    t = 0
    frameN = -1
    
    #------Prepare to start Routine "show_flash"-------
    t = 0
    show_flashClock01s2.reset()  # clock 
    frameN = -1
    # update component parameters for each repeat
    # flash begin routine
    f_change = 0
    
    # keep track of which components have finished
    show_flashComponents01s2 = []
    show_flashComponents01s2.append(frame_fl)
    for thisComponent in show_flashComponents01:
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    ########################################################################################
    ########################################################################################
    
    
    ########################################################################################
    # MAIN EXPERIMENT
    ########################################################################################
    
    #---Start Routine "show_flash"-------
    continueRoutine = True
    while continueRoutine:    
        # Hides mouse
        mouse = event.Mouse(visible=0)
        
        # get current time
        t = show_flashClock01s2.getTime()
        #print("t =", t)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        
        # update/draw components on each frame
        #print(frameN)
        
        # *frame_fl* updates
        if t >= 0.0 and frame_fl.status == NOT_STARTED:
            # keep track of start time/frame for later
            frame_fl.tStart = t  # underestimates by a little under one frame
            frame_fl.frameNStart = frameN  # exact frame index
            frame_fl.draw()
        # flash each frame
        if frameN >= f_change:
            flash_changes2()
            f_change+= f_t
#        if colour_order1 == 1:
#            strialtextb.draw()
#        elif colour_order1 == 2:
#            #strialtexto.draw()
        flash01s2.draw()  # First stimulus is drawn here
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineTimer01s2.reset()  # if we abort early the non-slip timer needs reset
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in show_flashComponents01s2:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
                
        # RESPONSE 1: (Left Side - BLUE)
        if event.getKeys(keyList=["escape"]):
            win.flip()
            breaktext.draw()
            win.flip()
            keypressed = event.waitKeys(timeStamped=False)
            checkclock01s2.reset()
        if event.getKeys(keyList=["6"]):
            win.close()
            core.quit()
        if event.getKeys(keyList=["z"]): # MORE key
        
            # Update practice trial counter
            pcounters2 = pcounters2+1
            
            # print the condition we did
            print("actual single trial done =", singleconditionsx)
            
            # Track response times
            #rt = rtclock.getTime()
            time01s2 = checkclock01s2.getTime()
            RTs2.append(time01s2)
            
            if colour_order1 == 1:
                if singleconditionsx <= 4:
                    correctresponses2.append('1')
                    print('response ===========  correct')
                elif singleconditionsx >= 5:
                    correctresponses2.append('0')
                    print('response ===========  incorrect')
            elif colour_order1 == 2:
                if singleconditionsx <= 4:
                    correctresponses2.append('0')
                    print('response ===========  incorrect')
                elif singleconditionsx >= 5:
                    correctresponses2.append('1')
                    print('response ===========  correct')
            # Append which colour question was being asked:
            colourcolour2.append(colour_order1)
            
            # Keep track of keys pressed
            keyspresseds2.append('left')
            
            # Update the counter
            counter01s2 = counter01s2+1
            
            # Keep track of trial number to be saved 
            trialNos2.append(counter01s2)
            
            
            # DRAW FIXATION CROSS AFTER EACH TRIAL
            win.flip() # Clears the window
            fcross.draw() # Draw the fixation cross
            win.flip() # Clears the window
            core.wait(1.5) # Keep the cross on screen for 2 seconds
            checkclock01s2.reset()
            event.clearEvents(eventType='keyboard')
            
            # END THE EXPERIMENT HERE AND SAVE DATA
            if counter01s2 == singletrials:
                win.flip() # Clears the window
                endtext0122.draw() # Draw ending message here
                endtext01229.draw()
                win.flip() # Clears the window
                keypressed = event.waitKeys(timeStamped=False)
            break # End the expriment
            
         # RESPONSE 2: (Right Side - ORANGE)
        if event.getKeys(keyList=["m"]): # LESS key
            
            
            # Update practice trial counter
            pcounters2 = pcounters2+1
            
            # print the condition we did
            print("actual single trial done =", singleconditionsx)
            
            time01s2 = checkclock01s2.getTime()
            RTs2.append(time01s2)
            
            if colour_order1 == 1:
                if singleconditionsx <= 4:
                    correctresponses2.append('0')
                    print('response ===========  incorrect')
                elif singleconditionsx >= 5:
                    correctresponses2.append('1')
                    print('response ===========  correct')
            elif colour_order1 == 2:
                if singleconditionsx <= 4:
                    correctresponses2.append('1')
                    print('response ===========  correct')
                elif singleconditionsx >= 5:
                    correctresponses2.append('0')
                    print('response ===========  incorrect')
            # Append which colour question was being asked:
            colourcolour2.append(colour_order1)
            
            # Keep track of keys pressed
            keyspresseds2.append('right')
            
            # Update the counter
            counter01s2 = counter01s2+1
            
            # Keep track of trial number to be saved 
            trialNos2.append(counter01s2)
            
            
            # DRAW FIXATION CROSS AFTER EACH TRIAL
            win.flip() # Clears the window
            fcross.draw() # Draw the fixation cross
            win.flip() # Clears the window
            core.wait(1.5) # Keep the cross on screen for 2 seconds
            checkclock01s2.reset()
            event.clearEvents(eventType='keyboard')
            
            # END THE EXPERIMENT HERE AND SAVE DATA
            if counter01s2 == singletrials:
                win.flip() # Clears the window
                endtext0122.draw() # Draw ending message here
                endtext01229.draw()
                win.flip() # Clears the window
                keypressed = event.waitKeys(timeStamped=False)
                nowbreak = nowbreak+1
            break # End the expriment
            
            
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
        else:  # this Routine was not non-slip safe so reset non-slip timer
            routineTimer.reset()
         
        # END THE EXPERIMENT HERE:
        if counter01s2 == singletrials:
            break
            
            
#-------Ending Routine "show_flash"-------
for thisComponent in show_flashComponents01s2:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
########################################################################################
########################################################################################




########################################################################################
########################################################################################
########################################################################################
# Paired Grid Trials - Second Block
########################################################################################
########################################################################################
########################################################################################
# Initialize components for Routine "init_experiment"
init_experimentClock = core.Clock()
# set_colors()
# Colors used during the experiment.s
def set_colors():
    global sc_c # screen color
    global f_c # frame color
    global sq_c # square color
    # 1 = white
    # -0.06 = grey 80
    # -0.37 = grey 120
    # -1 = black
    sc_c = 1
    f_c = -0.06
    sq_c = -0.37
    t_c = -0.06

# set_sizes()
# Sizes used during the experiment
def set_sizes():
    global f_s # frame size (square) (frame surrounding the stimulus)
    global sq_s # square size (square where the stimulus is shown)
    global l_s # line size (the width of the line surrounding the stimulus)
    f_s = 540
    sq_s = 800
    l_s = 100

########################################################################################
# Set conditions
########################################################################################
# Pairded conditions list
pairedconditionsB1 = [] # A1 close

# Merge everything into a conditions list:
for i in range(13):
    # CLOSE experimental trials:
    pairedconditionsB1.append(1)
    pairedconditionsB1.append(2)
    pairedconditionsB1.append(3)
    pairedconditionsB1.append(4)
    pairedconditionsB1.append(5)
    pairedconditionsB1.append(6)
    pairedconditionsB1.append(7)
    pairedconditionsB1.append(8)
    pairedconditionsB1.append(9)
    pairedconditionsB1.append(10)
    pairedconditionsB1.append(11)
    pairedconditionsB1.append(12)
    pairedconditionsB1.append(13)
    pairedconditionsB1.append(14)
    pairedconditionsB1.append(15)
    pairedconditionsB1.append(16)


# Conditions for practice trials 
pairedconditionsB1xx = [1,13,5,12,17,24]
np.random.shuffle(pairedconditionsB1xx) # Randomly shuffle paired grid practice trials

# Randomly shuffle all the conditions
np.random.shuffle(pairedconditionsB1)
########################################################################################
########################################################################################

########################################################################################
# Set main conditions and loop
########################################################################################
# Set the colour order for the first colour block:
colour_order1 = colour_order[1]

# Counter to keep track of things
pcounter2 = 1
counter = 0
thecount = 0
ycounter = practicetrials+1
supercounter = 0
break_count = 0
pcounter2 = practicetrials
    
    
xcounter = 0
for j in range(pairedtrials): # Should be 160 to make 320 paired grid trials in total
     
    pairedconditionsx = pairedconditionsB1[xcounter] # CLOSE block with experimental and control block
    
    # Collect what condiiton we are on:
    if  ycounter > practicetrials:
        # Append the condition and the probabilities given
        if colour_order1 == 1: # If colour is Blue
            if pairedconditionsx == 1:
                conused4.append('B1,B1')
                difflevel4.append('Exp - Easy 1 & Easy 1')
            elif pairedconditionsx == 2:
                conused4.append('B2,B2')
                difflevel4.append('Exp - Easy 2 & Easy 2')
            elif pairedconditionsx == 3:
                conused4.append('O1,B1')
                difflevel4.append('Exp - Easy 1 & Easy 1')
            elif pairedconditionsx == 4:
                conused4.append('O2,B2')
                difflevel4.append('Exp - Easy 2 & Easy 2')
            elif pairedconditionsx == 5:
                conused4.append('b1,b1')
                difflevel4.append('Exp - Hard 1 & Hard 1')
            elif pairedconditionsx == 6:
                conused4.append('b2,b2')
                difflevel4.append('Exp - Hard 2 & Hard 2')
            elif pairedconditionsx == 7:
                conused4.append('o1,b1')
                difflevel4.append('Exp - Hard 1 & Hard 1')
            elif pairedconditionsx == 8:
                conused4.append('o2,b2')
                difflevel4.append('Exp - Hard 2 & Hard 2')
            elif pairedconditionsx == 9:
                conused4.append('b1,B1')
                difflevel4.append('Con - Hard 1 & Easy 1')
            elif pairedconditionsx == 10:
                conused4.append('b2,B2')
                difflevel4.append('Con - Hard 2 & Easy 2')
            elif pairedconditionsx == 11:
                conused4.append('o1,B1')
                difflevel4.append('Con - Hard 1 & Easy 1')
            elif pairedconditionsx == 12:
                conused4.append('o2,B2')
                difflevel4.append('Con - Hard 2 & Easy 2')
            elif pairedconditionsx == 13:
                conused4.append('B1,o1')
                difflevel4.append('Con - Easy 1 & Hard 1')
            elif pairedconditionsx == 14:
                conused4.append('B2,o2')
                difflevel4.append('Con - Easy 2 & Hard 2')
            elif pairedconditionsx == 15:
                conused4.append('B1,b1')
                difflevel4.append('Con - Easy 1 & Hard 1')
            elif pairedconditionsx == 16:
                conused4.append('B2,b2')
                difflevel4.append('Con - Easy 2 & Hard 2')
                
                
        elif colour_order1 == 2: # If colour is Orange
            if pairedconditionsx == 1:
                conused4.append('B1,O1')
                difflevel4.append('Exp - Easy 1 & Easy 1')
            elif pairedconditionsx == 2:
                conused4.append('B2,O2')
                difflevel4.append('Exp - Easy 2 & Easy 2')
            elif pairedconditionsx == 3:
                conused4.append('O1,O1')
                difflevel4.append('Exp - Easy 1 & Easy 1')
            elif pairedconditionsx == 4:
                conused4.append('O2,O2')
                difflevel4.append('Exp - Easy 2 & Easy 2')
            elif pairedconditionsx == 5:
                conused4.append('b1,o1')
                difflevel4.append('Exp - Hard 1 & Hard 1')
            elif pairedconditionsx == 6:
                conused4.append('b2,o2')
                difflevel4.append('Exp - Hard 2 & Hard 2')
            elif pairedconditionsx == 7:
                conused4.append('o1,o1')
                difflevel4.append('Exp - Hard 1 & Hard 1')
            elif pairedconditionsx == 8:
                conused4.append('o2,o2')
                difflevel4.append('Exp - Hard 2 & Hard 2')
            elif pairedconditionsx == 9:
                conused4.append('O1,b1')
                difflevel4.append('Con - Easy 1 & Hard 1')
            elif pairedconditionsx == 10:
                conused4.append('O2,b2')
                difflevel4.append('Con - Easy 2 & Hard 2')
            elif pairedconditionsx == 11:
                conused4.append('O1,o1')
                difflevel4.append('Con - Easy 1 & Hard 1')
            elif pairedconditionsx == 12:
                conused4.append('O2,o2')
                difflevel4.append('Exp - Easy 2 & Hard 2')
            elif pairedconditionsx == 13:
                conused4.append('b1,O1')
                difflevel4.append('Con - Hard 1 & Easy 1')
            elif pairedconditionsx == 14:
                conused4.append('b2,O2')
                difflevel4.append('Con - Hard 2 & Easy 2')
            elif pairedconditionsx == 15:
                conused4.append('o1,O1')
                difflevel4.append('Con - Hard 1 & Easy 1')
            elif pairedconditionsx == 16:
                conused4.append('o2,O2')
                difflevel4.append('Con - Hard 2 & Easy 2')
        
    # Set the conditions here:
    #############################################
    # The paired grid trials:
    #############################################
    if colour_order1 == 1: # IF THE QUESTION IS MORE BLUE:
        # E,E: (BB) Level 1 & 2:
        if pairedconditionsx == 1:
            colour = colour_order1
            p1 = .65
            p2 = .65
        elif pairedconditionsx == 2:
            colour = colour_order1
            p1 = .60
            p2 = .60
            
        # E,E: (OB) Level 1 & 2:
        elif pairedconditionsx == 3:
            colour = colour_order1
            p1=.35
            p2=.65
        elif pairedconditionsx == 4:
            colour = colour_order1
            p1=.40
            p2=.60
        
        # H,H: (bb) level 1 & 2:
        elif pairedconditionsx == 5:
            colour= colour_order1
            p1=.54
            p2=.54
        elif pairedconditionsx == 6:
            colour= colour_order1
            p1=.52
            p2=.52
        
        # H,H: (ob) level 1 & 2:
        elif pairedconditionsx == 7:
            colour= colour_order1
            p1=.46
            p2=.54
        elif pairedconditionsx == 8:
            colour= colour_order1
            p1=.48
            p2=.52
        
        # H,E: (bB) level 1 & 2:
        if pairedconditionsx == 9:
            colour = colour_order1
            p1 = .54
            p2 = .65
        elif pairedconditionsx == 10:
            colour = colour_order1
            p1 = .52
            p2 = .60
            
        # H,E: (oB) level 1 & 2:
        elif pairedconditionsx == 11:
            colour = colour_order1
            p1=.46
            p2=.65
        elif pairedconditionsx == 12:
            colour = colour_order1
            p1=.48
            p2=.60
        
        # E,H: (Bo) level 1 & 2:
        elif pairedconditionsx == 13:
            colour= colour_order1
            p1=.65
            p2=.46
        elif pairedconditionsx == 14:
            colour= colour_order1
            p1=.60
            p2=.48
        
        # E,H: (Bb) level 1 & 2:
        elif pairedconditionsx == 15:
            colour= colour_order1
            p1=.65
            p2=.54
        elif pairedconditionsx == 16:
            colour= colour_order1
            p1=.60
            p2=.52
            
    if colour_order1 == 2: # IF THE QUESTION IS MORE ORANGE:
        # E,E: (BO) level 1 & 2:
        if pairedconditionsx == 1:
            colour = colour_order1
            p1 = .35
            p2 = .65
        elif pairedconditionsx == 2:
            colour = colour_order1
            p1 = .40
            p2 = .60
            
        # E,E: (OO) level 1 & 2:
        elif pairedconditionsx == 3:
            colour = colour_order1
            p1=.65
            p2=.65
        elif pairedconditionsx == 4:
            colour = colour_order1
            p1=.60
            p2=.60
        
        # H,H: (bo) level 1 & 2:
        elif pairedconditionsx == 5:
            colour= colour_order1
            p1=.46
            p2=.54
        elif pairedconditionsx == 6:
            colour= colour_order1
            p1=.48
            p2=.52
        
        # H,H: (oo) level 1 & 2:
        elif pairedconditionsx == 7:
            colour= colour_order1
            p1=.54
            p2=.54
        elif pairedconditionsx == 8:
            colour= colour_order1
            p1=.52
            p2=.52
        
        # H,E: (bO) level 1 & 2 :
        if pairedconditionsx == 9:
            colour = colour_order1
            p1 = .46
            p2 = .65
        elif pairedconditionsx == 10:
            colour = colour_order1
            p1 = .48
            p2 = .60
            
        # H,E: (oO) level 1 & 2:
        elif pairedconditionsx == 11:
            colour = colour_order1
            p1=.54
            p2=.65
        elif pairedconditionsx == 12:
            colour = colour_order1
            p1=.52
            p2=.60
        
        # E,H: (Ob) level 1 & 2:
        elif pairedconditionsx == 13:
            colour= colour_order1
            p1=.65
            p2=.46
        elif pairedconditionsx == 14:
            colour= colour_order1
            p1=.60
            p2=.48
        
        # E,H: (Oo) level 1 & 2:
        elif pairedconditionsx == 15:
            colour= colour_order1
            p1=.65
            p2=.54
        elif pairedconditionsx == 16:
            colour= colour_order1
            p1=.60
            p2=.52
        
    #############################################
    #############################################
    
    
    
    
    #############################################
    #############################################
    # Set the distances for the stimuli
    #############################################
    #############################################
    if 1 <= pairedconditionsx <= 8:
        leftside  = [-8.5,0]
        rightside = [8.5,0]
    #############################################
    #############################################
    
    
    # Set the position of left stimulus
    def set_positions():
        global fl_p # Where should the flash be drawn
        fl_p = leftside
            
    # Set the position of right stimulus
    def set_positions2():
        global fl_p2 # Where should the flash be drawn
        fl_p2 = rightside
        
    # flash stimulus functions
    # flash initialization
    def flash_init(win, position=[0,0], position2=[0,0], square_size=10, columns=20, rows=20, percent_color1=p1, percent_color2=p2): # Colour 1 being manipulated
        global flash # The flash stimulus (an array of flashing squares)
        global flash2
        
        if colour == 1:
            color_set = [color2, color1]   # Blue
            color_set2 = [color2, color1]  # Blue
        elif colour == 2:
            color_set = [color1, color2]   # Orange
            color_set2 = [color1, color2]  # Orange
        cell_number = columns * rows
    
        num_color1 = int(np.floor(float(cell_number)*percent_color1)) # First colour
        num_color2 = int(np.floor(float(cell_number)*(1-percent_color1))) # Second colour
    
        num_color3 = int(np.floor(float(cell_number)*percent_color2)) # First colour
        num_color4 = int(np.floor(float(cell_number)*(1-percent_color2))) # Second colour
        
        # fill an array with colors. Each color should appear approximatively the same number of times.
        f_colors = []
        for i in range(num_color1):
            f_colors.append(color_set[0])
        for i in range(num_color2):
            f_colors.append(color_set[1])
        numpy.random.shuffle(color_set)
        i = cell_number - len(f_colors)
        while i > 0:
            f_colors.append(color_set[i])
            i -= 1
        
        f_colors2 = []
        for i in range(num_color3):
            f_colors2.append(color_set2[0])
        for i in range(num_color4):
            f_colors2.append(color_set2[1])
        numpy.random.shuffle(color_set2)
        i = cell_number - len(f_colors2)
        while i > 0:
            f_colors2.append(color_set2[i])
            i -= 1
        
        # randomize color order.
        shuffle(f_colors)
        shuffle(f_colors2)
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys.append((x_left + c * square_size, y_top + l * square_size))
        
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys2 = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys2.append((x_left + c * square_size, y_top + l * square_size))
        
        # MAIN FUNCTION TO CREATE FIRST GRID
        flash = visual.ElementArrayStim(win=win,
                            fieldPos=position,
                            fieldShape='sqr',
                            nElements=cell_number,
                            sizes=square_size,
                            xys=xys,
                            colors=f_colors,
                            elementTex=None,
                            elementMask=None,
                            name='flash',
                            autoLog=False)
                            
        # MAIN FUNCTION TO CREATE SECOND GRID
        flash2 = visual.ElementArrayStim(win=win,
                        fieldPos=position2,
                        fieldShape='sqr',
                        nElements=cell_number,
                        sizes=square_size,
                        xys=xys2,
                        colors=f_colors2,
                        elementTex=None,
                        elementMask=None,
                        name='flash',
                        autoLog=False)
                            
                            
    
    # flash stimulus change
    def flash_change():
        global flash
        shuffle(flash.colors)
        flash.setColors(flash.colors)
    
    def flash2_change():
        global flash2
        shuffle(flash2.colors)
        flash2.setColors(flash2.colors)
    
    # Time variables used during the experiment
    def set_timing():
        global f_t 
        f_t = 5 # The duration (in frame) of a flash image presentation
    
    # data_init
    set_colors()
    set_sizes()
    set_positions()
    set_positions2()
    set_timing()
    
    #############################
    # MAIN FUNCTION HERE
    flash_init(win, fl_p, fl_p2, square_size=0.3, columns=20, rows=20) # set the parameters here for the function!!
    #############################
    
    # Initialize components for Routine "show_flash"
    show_flashClock = core.Clock()
    frame_fl = visual.ImageStim(win=win, name='frame_fl',
        image=None, mask=None,
        ori=0, pos=fl_p, size=f_s,
        color=f_c, colorSpace='rgb', opacity=1,
        flipHoriz=False, flipVert=False,
        texRes=128, interpolate=True, depth=0.0)
    
    # Create some handy timers
    globalClock = core.Clock()  # to track the time since experiment started
    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine 
    
    #------Prepare to start Routine "init_experiment"-------
    t = 0
    frameN = -1
    
    #------Prepare to start Routine "show_flash"-------
    t = 0
    show_flashClock.reset()  # clock 
    frameN = -1
    # update component parameters for each repeat
    # flash begin routine
    f_change = 0
    
    # keep track of which components have finished
    show_flashComponents = []
    show_flashComponents.append(frame_fl)
    for thisComponent in show_flashComponents:
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    ########################################################################################
    ########################################################################################
    
    
    ########################################################################################
    # MAIN EXPERIMENT
    ########################################################################################
    
    # More Introduction text to section 2 of block 2:
    if counter == 0:
        win.flip()
        sec_2.draw()
        sec_29.draw()
        win.flip()
        keypressed = event.waitKeys(timeStamped=False)
    
    # If P's are doing experimental trials then have introduction text at the start of each block:
    if ycounter > practicetrials:
        if counter == 0 and colour_order1 == 1:
            win.flip()
            blockfourthtext.draw()
            blockonetext150.draw()
            win.flip()
            keypressed = event.waitKeys(timeStamped=False)
            checkclock.reset()
        elif counter == 0 and colour_order1 == 2:
            win.flip()
            blocktwotext.draw()
            blockonetext150.draw()
            win.flip()
            keypressed = event.waitKeys(timeStamped=False)
            checkclock.reset()
            
            
            
#        print('condition ================', pairedconditionsx)
#        print('colour_order1 ==========', colour_order1)
#        print('colour ==================', colour)
#        print('p1 ====================', p1)
#        print('p2 ====================', p2)
            
            
            
            
    #---Start Routine "show_flash"-------
    continueRoutine = True
    while continueRoutine:
            
        # Hides mouse
        mouse = event.Mouse(visible=0)
        
        # get current time
        t = show_flashClock.getTime()
        #print("t =", t)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        
        # *frame_fl* updates
        if t >= 0.0 and frame_fl.status == NOT_STARTED:
            # keep track of start time/frame for later
            frame_fl.tStart = t  # underestimates by a little under one frame
            frame_fl.frameNStart = frameN  # exact frame index
            frame_fl.draw()
        # flash each frame
        if frameN >= f_change:
            flash_change()
            flash2_change()
            f_change += f_t
        
            
        flash.draw()  # First stimulus is drawn here
        flash2.draw() # Second stimulus is drawn here
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineTimer.reset()  # if we abort early the non-slip timer needs reset
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in show_flashComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        
        
        if ycounter <= practicetrials:
            if event.getKeys(keyList=["z"]):
                # Update the ycounter:
                ycounter = ycounter+1
                if pairedconditionsx is 1 or pairedconditionsx is 13:
                    win.flip()
                    incorrect_res.draw()
                    win.flip()
                    core.wait(2.0)
                else:
                    win.flip()
                    correct_res.draw()
                    win.flip()
                    core.wait(2.0)
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock.reset()
                break
            elif event.getKeys(keyList=["m"]):
                # Update the ycounter:
                ycounter = ycounter+1
                if pairedconditionsx is 1 or pairedconditionsx is 13:
                    win.flip()
                    correct_res.draw()
                    win.flip()
                    core.wait(2.0)
                else:
                    win.flip()
                    incorrect_res.draw()
                    win.flip()
                    core.wait(2.0)
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock.reset()
                break
        # Experimental trials:
        elif ycounter > practicetrials:
            if event.getKeys(keyList=["escape"]):
                win.flip()
                breaktext.draw()
                win.flip()
                keypressed = event.waitKeys(timeStamped=False)
                checkclock.reset()
            if event.getKeys(keyList=["6"]):
                win.close()
                core.quit()
            # RESPONSE 1: (Left Side)
            if event.getKeys(keyList=["z"]): # MORE OF A COLOUR
                
                # Update pcounter2
                pcounter2 = pcounter2+1
                
                # Update the ycounter
                ycounter = ycounter+1
                
                # Update the xcounter:
                xcounter = xcounter+1
                
                # Collect correct/incorrect responses
                if colour_order1 == 1: # If question is more     
                    if pairedconditionsx is 1 or pairedconditionsx is 3 or pairedconditionsx is 5 or pairedconditionsx is 6 or pairedconditionsx is 9 or pairedconditionsx is 10 or pairedconditionsx is 15 or pairedconditionsx is 16:
                        correctresponse2p2.append('1')
                    else:
                        correctresponse2p2.append('0')
                elif colour_order1 == 2:
                    if pairedconditionsx is 3 or pairedconditionsx is 4 or pairedconditionsx is 7 or pairedconditionsx is 8 or pairedconditionsx is 11 or pairedconditionsx is 12 or pairedconditionsx is 15 or pairedconditionsx is 16:
                        correctresponse2p2.append('1')
                    else:
                        correctresponse2p2.append('0')
                
                # Keep track of keys pressed
                keyspressed2p2.append('left')
                
                # Update the counters:
                counter = counter+1
                
                # Keep track of trial number to be saved 
                trialNo2p2.append(counter)
                print('trial number =', trialNo2)
                
                time2 = checkclock.getTime()
                RT2p2.append(time2)
                
                # DRAW FIXATION CROSS AFTER EACH TRIAL
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock.reset()
                event.clearEvents(eventType='keyboard')
                
                # END THE EXPERIMENT HERE AND SAVE DATA
                if counter == pairedtrials:
                    win.flip() # Clears the window
                    endtext1.draw() # Draw ending message here
                    win.flip() # Clears the window
                    core.wait(5.0)
                    win.flip()
                    #####################################################################
                    #Write Data To File
                    #####################################################################
                    
                    # Write RESULTS To A File 
                    os.chdir("Flash_Grid_Results") # move to folder called RESULTS, need to CREATE this if it does not exist already.
                    fout = open(filename, 'w')
                    fout.write('Trial Number, Response, Correct/Incorrect(1/0), RT, Condition, Difficulty, Colour Order (Single Grids Only)\n')
                    for i in range(singletrials):
                        fout.write('%d\t'% trialNo[i],)
                        fout.write('%s\t'% keyspressed[i],)
                        fout.write('%s\t'% correctresponse[i],)
                        fout.write('%.3f\t'% RT[i],)
                        fout.write('%s\t'% conused[i],)
                        fout.write('%s\t'% difflevel[i],)
                        fout.write('%s\t\n'% colourcolour1[i],)
                        
#                        fout.write('\n')
                    for i in range(pairedtrials):
                        fout.write('%d\t'% trialNo2[i],)
                        fout.write('%s\t'% keyspressed2[i],)
                        fout.write('%s\t'% correctresponse2[i],)
                        fout.write('%.3f\t'% RT2[i],)
                        fout.write('%s\t'% conused2[i],)
                        fout.write('%s\t\n'% difflevel2[i],)
                        

                    
#                        fout.write('\n')
                    for i in range(singletrials):
                        fout.write('%d\t'% trialNos2[i],)
                        fout.write('%s\t'% keyspresseds2[i],)
                        fout.write('%s\t'% correctresponses2[i],)
                        fout.write('%.3f\t'% RTs2[i],)
                        fout.write('%s\t'% conused3[i],)
                        fout.write('%s\t'% difflevel3[i],)
                        fout.write('%s\t\n'% colourcolour2[i],)
                        
#                        fout.write('\n')
                    for i in range(pairedtrials):
                        fout.write('%d\t'% trialNo2p2[i],)
                        fout.write('%s\t'% keyspressed2p2[i],)
                        fout.write('%s\t'% correctresponse2p2[i],)
                        fout.write('%.3f\t'% RT2p2[i],)
                        fout.write('%s\t'% conused4[i],)
                        fout.write('%s\t\n'% difflevel4[i],)
                        

                    
                    # Close the results data file
                    fout.close()
                    
                    #Say Where Results Are Written & If Experiment Successful
                    print('Results Written To File Called ' + filename) 
                    print('Program Completed Successfuly.')
                    ####################################################################
                    ####################################################################
                    
                    win.close()
                    core.quit()
                break
                
             # RESPONSE 2: (Right Side)
            if event.getKeys(keyList=["m"]): # LESS OF A COLOUR
                
                # Update pcounter2
                pcounter2 = pcounter2+1
                
                # Update the ycounter
                ycounter = ycounter+1
                
                # Update the ycounter:
                xcounter = xcounter+1
                
                
                # Collect correct/incorrect responses:
                if colour_order1 == 1: # If question is more     
                    if pairedconditionsx is 3 or pairedconditionsx is 4 or pairedconditionsx is 7 or pairedconditionsx is 8 or pairedconditionsx is 11 or pairedconditionsx is 12 or pairedconditionsx is 13 or pairedconditionsx is 14:
                        correctresponse2p2.append('1')
                    else:
                        correctresponse2p2.append('0')
                elif colour_order1 == 2:
                    if pairedconditionsx is 1 or pairedconditionsx is 2 or pairedconditionsx is 5 or pairedconditionsx is 6 or pairedconditionsx is 9 or pairedconditionsx is 10 or pairedconditionsx is 13 or pairedconditionsx is 14:
                        correctresponse2p2.append('1')
                    else:
                        correctresponse2p2.append('0')
                    
                # Keep track of keys pressed:
                keyspressed2p2.append('right')
                
                # Update the counter
                counter = counter+1
                
                # Keep track of trial number to be saved 
                trialNo2p2.append(counter)
                
                time2 = checkclock.getTime()
                RT2p2.append(time2)
                
                # DRAW FIXATION CROSS AFTER EACH TRIAL
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock.reset()
                event.clearEvents(eventType='keyboard')
                
                # END THE EXPERIMENT HERE AND SAVE DATA
                if counter == pairedtrials:
                    win.flip() # Clears the window
                    endtext1.draw() # Draw ending message here
                    win.flip() # Clears the window
                    core.wait(5.0)
                    win.flip()
                    #####################################################################
                    #Write Data To File
                    #####################################################################
                    
                    # Write RESULTS To A File 
                    os.chdir("Flash_Grid_Results") # move to folder called RESULTS, need to CREATE this if it does not exist already.
                    fout = open(filename, 'w')
                    fout.write('Trial Number, Response, Correct/Incorrect(1/0), RT, Condition, Difficulty, Colour Order (Single Grids Only)\n')
                    for i in range(singletrials):
                        fout.write('%d\t'% trialNo[i],)
                        fout.write('%s\t'% keyspressed[i],)
                        fout.write('%s\t'% correctresponse[i],)
                        fout.write('%.3f\t'% RT[i],)
                        fout.write('%s\t'% conused[i],)
                        fout.write('%s\t'% difflevel[i],)
                        fout.write('%s\t\n'% colourcolour1[i],)
                        
#                        fout.write('\n')
                    for i in range(pairedtrials):
                        fout.write('%d\t'% trialNo2[i],)
                        fout.write('%s\t'% keyspressed2[i],)
                        fout.write('%s\t'% correctresponse2[i],)
                        fout.write('%.3f\t'% RT2[i],)
                        fout.write('%s\t'% conused2[i],)
                        fout.write('%s\t\n'% difflevel2[i],)
                    
#                        fout.write('\n')
                    for i in range(singletrials):
                        fout.write('%d\t'% trialNos2[i],)
                        fout.write('%s\t'% keyspresseds2[i],)
                        fout.write('%s\t'% correctresponses2[i],)
                        fout.write('%.3f\t'% RTs2[i],)
                        fout.write('%s\t'% conused3[i],)
                        fout.write('%s\t'% difflevel3[i],)
                        fout.write('%s\t\n'% colourcolour2[i],)
                        
#                        fout.write('\n')
                    for i in range(pairedtrials):
                        fout.write('%d\t'% trialNo2p2[i],)
                        fout.write('%s\t'% keyspressed2p2[i],)
                        fout.write('%s\t'% correctresponse2p2[i],)
                        fout.write('%.3f\t'% RT2p2[i],)
                        fout.write('%s\t'% conused4[i],)
                        fout.write('%s\t\n'% difflevel4[i],)
                    
                    # Close the results data file
                    fout.close()
                    
                    #Say Where Results Are Written & If Experiment Successful
                    print('Results Written To File Called ' + filename) 
                    print('Program Completed Successfuly.')
                    ####################################################################
                    ####################################################################
                    
                    win.close()
                    core.quit()
                break
                 
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
        else:  # this Routine was not non-slip safe so reset non-slip timer
            routineTimer.reset()
        
    
        
#-------Ending Routine "show_flash"-------
for thisComponent in show_flashComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
########################################################################################
########################################################################################mm
