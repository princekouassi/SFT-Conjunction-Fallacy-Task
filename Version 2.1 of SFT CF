from __future__ import print_function
from __future__ import division
from __future__ import division  # so that 1/3=0.333 instead of 1/3=0
from psychopy import visual, core, data, event, logging, sound, gui
from psychopy.constants import *  # things like STARTED, FINISHED
import numpy as np  # whole numpy lib is available, prepend 'np.'
from numpy import sin, cos, tan, log, log10, pi, average, sqrt, std, deg2rad, rad2deg, linspace, asarray
from numpy.random import random, randint, normal, shuffle
import os  # handy system and path functions
import time
import copy
import math
import random
import numpy
from array import array
import datetime
from psychopy import prefs
prefs.general['audioLib'] = ['pygame']
from psychopy import visual,core,data,event,gui
from psychopy import sound
from psychopy.constants import *  # things like STARTED, FINISHED
import csv
#
#
#
#
#
#
#
# Last updated on: 13/12/2019
#
#
#
#
#
#
#
#
#

########################################################################################
# Draw a box to get experiment and participant information
########################################################################################
expName = u'Flashing_grid_task'  # Name the experiment
expInfo = {u'Session': u'001', u'Participant': u'001'} # What the box should ask for
dlg = gui.DlgFromDict(dictionary=expInfo, title=expName) # Draw the bloody box!
if dlg.OK == False: core.quit() # If "cancel" is clicked end the whole thing
expInfo['date'] = data.getDateStr()  # add a simple timestamp
expInfo['expName'] = expName
########################################################################################
########################################################################################


########################################################################################
# Where To Write File
########################################################################################
# Setup files for saving
if not os.path.isdir('Flash_Grid_Results'): # Create this folder wherever this script is saved
    os.makedirs('Flash_Grid_Results')  # If this fails (e.g. permissions) we will get error
filename = 'Flash_Grid_Experiment_' + '%s_%s' %(expInfo['Participant'], expInfo['date'])+'.txt'
print('filename used for data is ' +filename)
########################################################################################
########################################################################################


########################################################################################
# Define the window
########################################################################################
# flag for 'escape' or other condition => quit the exp
endExpNow = False

# Setup the Window
win = visual.Window(fullscr=True, screen=0, allowGUI=True, allowStencil=False,
    monitor='testMonitor', color='grey', colorSpace='rgb',
    blendMode='avg', useFBO=True,
    units='cm')
# store frame rate of monitor if we can measure it successfully
expInfo['frameRate']=win.getActualFrameRate()
if expInfo['frameRate']!=None:
    frameDur = 1.0/round(expInfo['frameRate'])
else:
    frameDur = 1.0/60.0 # couldn't get a reliable measure so guess 
########################################################################################
########################################################################################


########################################################################################
# Changeable experimental parameters
########################################################################################
# Number of experimental trials
singletrials = 2#40    # Number of single trials PER block
pairedtrials = 2#208     # Number of paired trials PER block
cali_trials = 24 # Determine the total number of calibration trial
practicetrials = 2   # Number of practice trials for single AND paired grid trials
practicetrials_pass = 2 # The number of practice trials you need to complete in a row to move onto next stage
singletrials_total = practicetrials+singletrials # The calculated TOTAL amount of practice and experimental single grid trials 
pairedtrials_total = practicetrials+pairedtrials# The calculated TOTAL amount of practice and experimental paired grid trials
infin_run = 1000 # Run the block with an "infinite" number of trials untill I tell it to break!
hard_proportion = .52 # Determine here what the had grid trial prportion should be!

# Text size:
textsize = 0.7

# Fixation cross:
fcross = visual.TextStim(win, text="+")   

# The total number of tirals for the paired grid coniditons:
sumtotal = 2 # This should be the same number as pairedtrials

# Block seperation text
sep_text ='''The last block of the experiment will now begin'''
seperation_text = visual.TextStim(win, text=sep_text, height=textsize)



####################
# Single trials text s1
####################
# Introduction text
one01 = '''During the experiment you will be presented with single and paired grid trials. During single grid trials, you will be presented with a sequence of trials each containing one flashing grid made up of a random number of blue and orange patches. An example grid is shown below.'''
introtext01 = visual.TextStim(win, text=one01,pos=(0.9, 11), height=textsize)  
one111 = '''Before each set of single grid trials you will be asked if there are either more Blue or Orange patches in the grid, which you must then answer on subsequent trials.'''
introtext019 = visual.TextStim(win, text=one111,pos=(0.9, 6), height=textsize) 
one1112 = '''E.g. for the example grid below you may be asked: "Does the grid have more Blue than Orange patches? Press 'z' for YES or 'm' for NO."'''
introtext0191 = visual.TextStim(win, text=one1112,pos=(0.5, 2), height=textsize) 
one1113 = '''Press the spacebar to continue...'''
introtext0192 = visual.TextStim(win, text=one1113,pos=(0.3, -9), height=textsize) 
# Introduction text 2.0
one0001 = '''For section 2 of the block, on each trial you will be shown two flashing grids with varying distances between the grids. Both grids will have a randomly assigned proportion of blue to orange patches. Your task on each tiral of this section of the block is to make a judgement on the proportion of colours in both grids. You will be given practice trials before each section. PRESS ANY KEY ON THE KEYBOARD TO CONTINUE...'''
introtext0001 = visual.TextStim(win, text=one0001, height=textsize)
# Practice text:
practice01 = '''Practice for single grid trials will now begin. For these practice trials you must answer the following question on each trial: Does the grid have more Blue than Orange Patches? Press "z" for YES or "m" for NO.'''
practicetext1 = visual.TextStim(win, text=practice01,pos=(0,3), height=textsize) 
# Practice text:
practice0199 = '''Press any key on the keyboard to begin the practice trials...'''
practicetext17 = visual.TextStim(win, text=practice0199,pos=(-0.5,-0.5), height=textsize)
# End of first part of the experiment text
two01 = '''Single grid trials have now finished.'''
endtext01 = visual.TextStim(win, text=two01,pos=(-2.8,1.5), height=textsize)  
two010 = '''Press any key on the keyboard to continue...'''
endtext010 = visual.TextStim(win, text=two010,pos=(-1.4,0), height=textsize) 


# Practice trials for blue
prac001bf = '''Practice trials for single grid trials have now finished.'''
endspractice_bf = visual.TextStim(win, text=prac001bf,pos=(-0.7,3), height=textsize) 
prac001b1 = '''On the next set of trials you must answer the following question: Does the grid have more Blue than Orange Patches? Press "z" for YES or "m" for NO.'''
endspractice_b1 = visual.TextStim(win, text=prac001b1,pos=(-0.5,0), height=textsize) 
prac001b2 = '''Press any key on the keyboard to begin the actual trials...'''
endspractice_b2 = visual.TextStim(win, text=prac001b2,pos=(-0.8,-3), height=textsize) 
# Practice trials for orange
prac001of = '''Practice trials for single grid trials have now finished.'''
endspractice_of = visual.TextStim(win, text=prac001of,pos=(-0.7,3), height=textsize) 
prac001o1 = '''On the next set of trials you must answer the following question: Does the grid have more Orange than Blue Patches? Press "z" for YES or "m" for NO.'''
endspractice_o1 = visual.TextStim(win, text=prac001o1,pos=(-0.5,0), height=textsize) 
prac001o2 = '''Press any key on the keyboard to begin the actual trials...'''
endspractice_o2 = visual.TextStim(win, text=prac001o2,pos=(-0.8,-3), height=textsize) 
# Break text
breaktext01 = '''You are now on a break. Press any key on the keyboard to end your break and continue with the task immediately ...'''
breaktext = visual.TextStim(win, text=breaktext01, height=textsize) 
# Text on each trial for single grid trials
sttextb = '''Does the grid have more Blue than Orange patches? Press "z" for YES or "m" for NO.'''
strialtextb =blockonetext = visual.TextStim(win, text=sttextb, pos=(0, 6), height=textsize)
# Text on each trial for single grid trials
sttexto = '''Does the grid have more Orange than Blue patches? Press "z" for YES or "m" for NO.'''
strialtexto =blockonetext = visual.TextStim(win, text=sttexto, pos=(0, 6), height=textsize)
# Correct practice trial text:
cres = '''CORRECT'''
correct_res =blockonetext = visual.TextStim(win, text=cres, pos=(0,0), height=1)
# Inccorect practice trial text:
icres = '''INCORRECT'''
incorrect_res =blockonetext = visual.TextStim(win, text=icres, pos=(0,0), height=1)

####################
####################

####################
# Paired trials text s1
####################
# Introduction text
one = '''Introduction text here.'''
introtext = visual.TextStim(win, text=one, height=textsize)  

# End of experiment text
two = '''Please wait...'''
endtext = visual.TextStim(win, text=two, height=textsize)  

# End of the whole experiment text 
two22 = '''The experiment has now finished!'''
endtext1 = visual.TextStim(win, text=two22, height=textsize)  

# Section 2 practice trials text:
section2prac = '''Practice trials for paired grid trials will now begin. PRESS ANY KEY ON THE KEYBOARD TO BEGIN THE PRACTICE TRIALS...'''
section2practice = visual.TextStim(win, text=section2prac, height=textsize)

# Text on each trial for paired grid BLUE trials
ttext = '''Are there more Blue than Orange patches in both grids?  Press "z" for YES or "m" for NO.'''
trialtextb =blockonetext = visual.TextStim(win, text=ttext, pos=(0, 6), height=textsize)

# Text on each trial for paired grid ORANGE trials
ttexto = '''Are there more Orange than Blue patches in both grids?  Press "z" for YES or "m" for NO.'''
trialtexto =blockonetext = visual.TextStim(win, text=ttexto, pos=(0, 6), height=textsize)

####################
####################

####################
# Paired trials text
####################

# Seperation text after block 1:
sep_text ='''The last block of the experiment will now begin. Press any key on the keyboard to start the last block of the experiment...'''
seperation_text = visual.TextStim(win, text=sep_text, height=textsize)

####################
####################

####################
# Single trials text s2
####################
# Introduction text
one01e = '''On the next set of trials you must answer the following question: Does the grid have more Blue than Orange Patches? Press "z" for Yes or "m" for NO.'''
introtext0122b = visual.TextStim(win, text=one01e,pos=(0.3,2.5), height=textsize)  
one01ee = '''Press any key on the keyboard to begin the trials...'''
introtext0122bb = visual.TextStim(win, text=one01ee,pos=(-0.2,-1), height=textsize)  
one01et = '''On the next set of trials you must answer the following question: Does the grid have more Orange than Blue Patches? Press "z" for Yes or "m" for NO.'''
introtext0122o = visual.TextStim(win, text=one01et,pos=(0.3,2.5), height=textsize)  
one01eet = '''Press any key on the keyboard to begin the trials...'''
introtext0122oo = visual.TextStim(win, text=one01eet,pos=(-0.2,-1), height=textsize)  
# Practice text:
practice01 = '''Practice trials for section 1 of block 2 will now begin. PRESS ANY KEY ON THE KEYBOARD TO BEGIN THE PRACTICE TRIALS...'''
practicetext122 = visual.TextStim(win, text=practice01, height=textsize) 
# End of first part of the experiment text
two01 = '''Single grid trials have now finshed.'''
endtext0122 = visual.TextStim(win, text=two01,pos=(-1.7,0.5), height=textsize)  
two019 = '''Press any key on the keyboard to continue...'''
endtext01229 = visual.TextStim(win, text=two019,pos=(-0.2,-1), height=textsize)  
# Practice trials
prac001 = '''Practice trials for Section 1 of block 2 have now ended. Press any key on the keyboard to begin the actual trials for section 1 of block 2...'''
endspractice22 = visual.TextStim(win, text=prac001, height=textsize) 
# Break text
breaktext01 = '''You are now on a break. Press any key on the keyboard to end your break and continue with the task immediately...'''
breaktext = visual.TextStim(win, text=breaktext01, height=textsize) 
# Text on each trial for single grid trials
sttextb = '''Does the grid have more Blue than Orange patches? Press "z" for YES or "m" for NO.'''
strialtextb =blockonetext = visual.TextStim(win, text=sttextb, pos=(0, 6), height=textsize)
# Text on each trial for single grid trials
sttexto = '''Does the grid have more Orange than Blue patches? Press "z" for YES or "m" for NO.'''
strialtexto =blockonetext = visual.TextStim(win, text=sttexto, pos=(0, 6), height=textsize)
# Correct practice trial text:
cres = '''CORRECT'''
correct_res =blockonetext = visual.TextStim(win, text=cres, height=1)
# Inccorect practice trial text:
icres = '''INCORRECT'''
incorrect_res =blockonetext = visual.TextStim(win, text=icres, height=1)
# Practice trials
prac002 = '''Practice for paired grid trials has now finished.'''
endspractice2 = visual.TextStim(win, text=prac002,pos=(0,1.8), height=textsize) 

prac0020 = '''Press any key on the keyboard to begin the actual paired grid trials...'''
endspractice20 = visual.TextStim(win, text=prac0020, pos=(-0.3,0), height=textsize) 

####################
####################

####################
# Paired trials text s2
####################
# Introduction text
one = '''Introduction text here.'''
introtext = visual.TextStim(win, text=one, height=textsize)  
# End of experiment text
two = '''Please take a short break now, before continuing ...'''
endtext = visual.TextStim(win, text=two, height=textsize)  
# End of the whole experiment text 
two22 = '''The experiment has now finished!'''
endtext1 = visual.TextStim(win, text=two22, height=textsize)  
# Section 2 practice trials text:
section2prac = '''During paired grid trials, you will be presented with a sequence of trials each containing two flashing grids made up of a random number of blue and orange patches. Example grids are shown below.'''
section2practice22i = visual.TextStim(win, text=section2prac,pos=(0.9, 11), height=textsize)
one111t = '''Before each set of trials you will be asked if there are either more Blue or Orange patches in both grids, which you must then answer on subsequent trials.'''
section2practice22ii = visual.TextStim(win, text=one111t,pos=(1.2, 6), height=textsize) 
one1112t = '''E.g. for the example grids below you may be asked: "Are there more Orange than Blue patches in both grids? Press "z" for YES or "m" for NO."'''
section2practice22iii = visual.TextStim(win, text=one1112t,pos=(1.2, 2), height=textsize) 
one1113t = '''Press the spacebar to continue...'''
section2practice22iiii = visual.TextStim(win, text=one1113t,pos=(0.3, -10), height=textsize) 
practice01r = '''Practice trials for paired grids will now begin. For these practice trials you must answer the following question on each trial: Do both grids seperately have more Orange than Blue Patches? Press "z" for YES and "m" for NO.'''
practicetext1q = visual.TextStim(win, text=practice01r,pos=(0,3), height=textsize) 
# Practice text:
practice0199r = '''Press any key on the keyboard to begin the practice trials...'''
practicetext1qq = visual.TextStim(win, text=practice0199r,pos=(-0.5,0), height=textsize)
# Text on each trial for paired grid BLUE trials
ttext = '''Are there more Blue than Orange patches in both grids?  Press "z" for YES or "m" for NO.'''
trialtextb =blockonetext = visual.TextStim(win, text=ttext, pos=(0, 6), height=textsize)
# Text on each trial for paired grid ORANGE trials
ttexto = '''Are there more Orange than Blue patches in both grids?  Press "z" for YES or "m" for NO.'''
trialtexto =blockonetext = visual.TextStim(win, text=ttexto, pos=(0, 6), height=textsize)

# Block one intro text
bb1 = '''During the next set of trials two grids will be presented on screen with a moderate amount of seperation between them. On each trial you must answer the following question: Are there more Blue than Orange patches in both grids?  Press "z" for YES or "m" for NO.'''
blockonetext = visual.TextStim(win, text=bb1,pos=(0.3,2.5), height=textsize) 

# Block three intro text
bb3 = '''During the next set of trials two grids will be presented on screen with a moderate amount of seperation between them. On each trial you must answer the following question: Are there more Orange than Blue patches in both grids?  Press "z" for YES or "m" for NO.'''
blockthirdtext = visual.TextStim(win, text=bb3,pos=(0.3,2.5), height=textsize) 

# Block two intro text
bb2 = '''During the next set of trials two grids will be presented on screen close together. On each trial you must answer the following question: Are there more Orange than Blue patches in both grids?  Press "z" for YES or "m" for NO.'''
blocktwotext = visual.TextStim(win, text=bb2,pos=(0,2.5), height=textsize)

# Block four intro text
bb4 = '''During the next set of trials two grids will be presented on screen close together. On each trial you must answer the following question: Are there more Blue than Orange patches in both grids?  Press "z" for YES or "m" for NO.'''
blockfourthtext = visual.TextStim(win, text=bb4,pos=(0,2.5), height=textsize)

# Practice trials
prac002 = '''Practice trials for Section 2 of block 2 have now finished. Press any key on the keyboard to begin the actual trials for Section 2...'''
endspractice222 = visual.TextStim(win, text=prac002,pos=(0,0), height=textsize)  
# introduction to section 2 of block 2
sec2sec = '''Another set of paired grid trials will now begin.'''
sec_2 = visual.TextStim(win, text=sec2sec,pos=(0,2), height=textsize) 
sec2sec9 = '''Press any key on the key board to begin the trials...'''
sec_29 = visual.TextStim(win, text=sec2sec9,pos=(-0.3,0), height=textsize) 
# Block one intro text
bb150 = '''Press any key on the keyboard to begin the trials...'''
blockonetext150 = visual.TextStim(win, text=bb150,pos=(-0.3,-1), height=textsize) 
####################
####################



#############################
#############################
# End of practice trial text:
#############################
#############################

# Text if P got 0% of practice trials correct
zeroi_per = '''You got 0% of the practice trials correct. Wait for the experimenter before continuing.'''
zero_per = visual.TextStim(win, zeroi_per,pos=(0.0, 0), height=textsize,wrapWidth=40,alignHoriz = 'center')

# Text if P got 25% of practice trials correct
two_fivei_per = '''You got 25% of the practice trials correct. Wait for the experimenter before continuing.'''
two_five_per = visual.TextStim(win, two_fivei_per,pos=(0.0, 0), height=textsize,wrapWidth=40,alignHoriz = 'center')

# Text if P got 50% of practice trials correct
five_zeroi_per = '''You got 50% of the practice trials correct. Wait for the experimenter before continuing.'''
five_zero_per = visual.TextStim(win, five_zeroi_per,pos=(0.0, 0), height=textsize,wrapWidth=40,alignHoriz = 'center')

# Text if P got 75% of practice trials correct
seven_fivei_per = '''You got 75% of the practice trials correct. Wait for the experimenter before continuing.'''
seven_five_per = visual.TextStim(win, seven_fivei_per,pos=(0.0, 0), height=textsize,wrapWidth=40,alignHoriz = 'center')

# Text if P got 100% of practice trials correct
one_zero_zeroi_per = '''You got 100% of the practice trials correct. Wait for the experimenter before continuing.'''
zero_one_one_per = visual.TextStim(win, one_zero_zeroi_per,pos=(0.0, 0), height=textsize,wrapWidth=40,alignHoriz = 'center')

#############################
#############################



##########################################################################
##########################################################################
# Orange and Blue practice text:
##########################################################################
##########################################################################

# Practice trial text for single orange grids:
single_orangei = '''Practice for single grid trials will now begin. For these practice trials you must answer the following question on each trial: Does the grid have more Orange than Blue Patches? Press "z" for YES or "m" for NO.'''
single_orange = visual.TextStim(win, text=single_orangei,pos=(0,2), height=textsize, wrapWidth=30, alignHoriz = 'center') 

# Practice trial text for single blue grids:
single_bluei = '''Practice for single grid trials will now begin. For these practice trials you must answer the following question on each trial: Does the grid have more Blue than Orange Patches? Press "z" for YES or "m" for NO.'''
single_blue = visual.TextStim(win, text=single_bluei, pos=(0,2), height=textsize, wrapWidth=30, alignHoriz = 'center') 

# Practice trial text for paired blue grid:
paired_bluei = '''Practice trials for paired grids will now begin. For these practice trials you must answer the following question on each trial: Do both grids seperately have more Blue than Orange Patches? Press "z" for YES and "m" for NO.'''
paired_blue = visual.TextStim(win, text=paired_bluei, pos=(0,2), height=textsize, wrapWidth=30, alignHoriz = 'center') 

# Practice trial text for paired orange grid:
paired_orangei = '''Practice trials for paired grids will now begin. For these practice trials you must answer the following question on each trial: Do both grids seperately have more Orange than Blue Patches? Press "z" for YES and "m" for NO.'''
paired_orange = visual.TextStim(win, text=paired_orangei, pos=(0,2), height=textsize, wrapWidth=30, alignHoriz = 'center') 

# Text to say press any key to move onto next trial:
key_pressi = '''Press any key on the keyboard to begin the practice trials...'''
key_press = visual.TextStim(win, text=key_pressi,pos=(0,-2), height=textsize, wrapWidth=30, alignHoriz = 'center')

##########################################################################
##########################################################################



##########################################################################
##########################################################################
# Calibration Trial Text:
##########################################################################
##########################################################################

# End of MORE BLUE practice trials: 
prac001bf = '''Practice trials for single grid trials have now finished. You will now complete a short amount of trials to make sure you understand the task.'''
endspractice_bf = visual.TextStim(win, text=prac001bf, pos=(0,4), height=textsize, wrapWidth=30, alignHoriz = 'center') 
prac001b1 = '''On the next set of trials you must answer the following question: Does the grid have more Blue than Orange Patches? Press "z" for YES or "m" for NO.'''
endspractice_b1 = visual.TextStim(win, text=prac001b1, pos=(0,2), height=textsize, wrapWidth=30, alignHoriz = 'center') 

#End of MORE ORANGE practice trials:
prac001of = '''Practice trials for single grid trials have now finished. You will now complete a short amount of trials to make sure you understand the task.'''
endspractice_of = visual.TextStim(win, text=prac001of, pos=(0,4), height=textsize, wrapWidth=30, alignHoriz = 'center') 
prac001o1 = '''On the next set of trials you must answer the following question: Does the grid have more Orange than Blue Patches? Press "z" for YES or "m" for NO.'''
endspractice_o1 = visual.TextStim(win, text=prac001o1, pos=(0,2), height=textsize, wrapWidth=30, alignHoriz = 'center')

# Text at the end of practice trials:
two01e = '''You have successfully completed the test trials. Please wait for the experimenter '''
endtext01e = visual.TextStim(win, text=two01e, pos=(0,2), height=textsize, wrapWidth=30, alignHoriz = 'center')
two010e = '''Press any key on the keyboard to continue...'''
endtext010e = visual.TextStim(win, text=two010e, pos=(0,0), height=textsize, wrapWidth=30, alignHoriz = 'center')
##########################################################################
##########################################################################


########################################################################################
########################################################################################
# Orange:
color1 = [0.9686,0.6392,0.0353]
# Blue:
color2 = [-0.8980,1.0000,1.0000] 

# Define some clocks
checkclock01 = core.Clock() # For single grid trials     S1
checkclock = core.Clock() # For paired grid trials       P1
checkclock01s2 = core.Clock() # For single grid trials   S2
checkclock = core.Clock() # For paired grid trials       P2
########################################################################################
########################################################################################





########################################################################################
# List That Will Record Responses & RTs
########################################################################################
# For single grid trials s1
keyspressed = []*singletrials
correctresponse = []*singletrials
RT =[]*singletrials
trialNo = []*singletrials
conused = []*singletrials
difflevel = []*singletrials
colourcolour1 = []*singletrials

# For single grid trials s2
keyspresseds2 = []*singletrials
correctresponses2 = []*singletrials
RTs2 =[]*singletrials
trialNos2 = []*singletrials
conused2 = []*singletrials
difflevel2 = []*singletrials
colourcolour2 = []*singletrials

# For paired grid trial p1:
keyspressed2 = []*pairedtrials
correctresponse2 = []*pairedtrials
RT2 =[]*pairedtrials
trialNo2 = []*pairedtrials
conused3 = []*pairedtrials
blocknumber = []*pairedtrials
difflevel3 = []*pairedtrials

# For paired grid trial p2:
keyspressed2p2 = []*pairedtrials
correctresponse2p2 = []*pairedtrials
RT2p2 =[]*pairedtrials
trialNo2p2 = []*pairedtrials
conused4 = []*pairedtrials
blocknumberp2 = []*pairedtrials
difflevel4 = []*pairedtrials

# Calibration trials:
cali_correct = []

# Initilise the colour variable:
colour = []
########################################################################################
########################################################################################


########################################################################################
# Set the conditions for the single grid trials
########################################################################################
con1 = (1)
con2 = (2)
con3 = (3)
con4 = (4)

# Define the blue and orange block signle grid trials:
singleconditions_all = []


for i in range(10):
# The single grid trials for the blue block:
    singleconditions_all.append(con1)
    singleconditions_all.append(con2)
# The single grid trials for the orange block:
    singleconditions_all.append(con3)
    singleconditions_all.append(con4)
np.random.shuffle(singleconditions_all)

# Conditions for practice trials:
singlegridpractice = [2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4,2,4]
#np.random.shuffle(singlegridpractice) # Randomly shuffle single grid practice trials


# Create and shuffle which colour block participants will see first:
colour_order = [1,2] # 1 is the colour blue and 2 is the colour orange
np.random.shuffle(colour_order)
########################################################################################
########################################################################################


########################################################################################
# Set the conditions for the CALIBRATION STAGE:
########################################################################################
con10 = (10)
con20 = (20)
con30 = (30)
con40 = (40)
con50 = (50)
con60 = (60)
con70 = (70)
con80 = (80)

# Define the blue and orange calibration trials:
singleconditions_calibration = []


for i in range(3):
# The single grid trials for the blue block:
    singleconditions_calibration.append(con10)
    singleconditions_calibration.append(con20)
    singleconditions_calibration.append(con30)
    singleconditions_calibration.append(con40)
# The single grid trials for the orange block:
    singleconditions_calibration.append(con50)
    singleconditions_calibration.append(con60)
    singleconditions_calibration.append(con70)
    singleconditions_calibration.append(con80)
np.random.shuffle(singleconditions_calibration)
########################################################################################
########################################################################################



########################################################################################
########################################################################################
########################################################################################
# Single Grid Trials INTRODUCTION
########################################################################################
########################################################################################
########################################################################################
# Initialize components for Routine "init_experiment"
init_experimentClock = core.Clock()
# set_colors()
# Colors used during the experiment.s
def set_colors():
    global sc_c # screen color
    global f_c # frame color
    global sq_c # square color
    # 1 = white
    # -0.06 = grey 80
    # -0.37 = grey 120
    # -1 = black
    sc_c = 1
    f_c = -0.06
    sq_c = -0.37
    t_c = -0.06

# set_sizes()
# Sizes used during the experiment
def set_sizes():
    global f_s # frame size (square) (frame surrounding the stimulus)
    global sq_s # square size (square where the stimulus is shown)
    global l_s # line size (the width of the line surrounding the stimulus)
    f_s = 240
    sq_s = 200
    l_s = 200
    
# Set the position of left stimulus
def set_positions01():
    global fl_p3 # Where should the flash be drawn
    fl_p3 = [0, -4]

########################################################################################
# Set main conditions and loop
########################################################################################
    
p01 = .65#(65/35)

# flash stimulus functions
# flash initialization
def flash_init(win, position01=[0,0], square_size=10, columns=20, rows=20, percent_color01=p01): # Colour2 being manipulated whic is BLUE
    global flash01 # The flash stimulus (an array of flashing squares)

    color_set01 = [color2, color1] # color2 being manipulated which is the BLUE
    cell_number = columns * rows

    num_color4 = int(np.floor(float(cell_number)*percent_color01)) # First colour
    num_color5 = int(np.floor(float(cell_number)*(1-percent_color01))) # Second colour
    
    # fill an array with colors. Each color should appear approximatively the same number of times.
    f_colors3 = []
    for i in range(num_color4):
        f_colors3.append(color_set01[0])
    for i in range(num_color5):
        f_colors3.append(color_set01[1])
    numpy.random.shuffle(color_set01)
    i = cell_number - len(f_colors3)
    while i > 0:
        f_colors3.append(color_set01[i])
        i -= 1
    
    # randomize color order.
    shuffle(f_colors3)
    
    # fill an array with coordinate for each color square. First square should be at the upper left
    # and next should follow from left to right and up to down.
    xys = []
    x_left = (1 - columns) * square_size / 2
    y_top = (1 - rows) * square_size / 2
    for l in range(rows):
        for c in range(columns):
            xys.append((x_left + c * square_size, y_top + l * square_size))
    
    
    # fill an array with coordinate for each color square. First square should be at the upper left
    # and next should follow from left to right and up to down.
    xys2 = []
    x_left = (1 - columns) * square_size / 2
    y_top = (1 - rows) * square_size / 2
    for l in range(rows):
        for c in range(columns):
            xys2.append((x_left + c * square_size, y_top + l * square_size))
    
    # MAIN FUNCTION TO CREATE FIRST GRID
    flash01 = visual.ElementArrayStim(win=win,
                        fieldPos=position01,
                        fieldShape='sqr',
                        nElements=cell_number,
                        sizes=square_size,
                        xys=xys,
                        colors=f_colors3,
                        elementTex=None,
                        elementMask=None,
                        name='flash',
                        autoLog=False)
                        
                        
                        

# flash stimulus change
def flash_change():
    global flash01
    shuffle(flash01.colors)
    flash01.setColors(flash01.colors)

# Time variables used during the experiment
def set_timing():
    global f_t 
    f_t = 5 # The duration (in frame) of a flash image presentation

# data_init
set_colors()
set_sizes()
set_positions01()
set_timing()

#############################
# MAIN FUNCTION HERE
flash_init(win, fl_p3, square_size=0.3, columns=20, rows=20) # set the parameters here for the function!!
#############################

# Initialize components for Routine "show_flash"
show_flashClock01 = core.Clock()
frame_fl = visual.ImageStim(win=win, name='frame_fl',
    image=None, mask=None,
    ori=0, pos=fl_p3, size=f_s,
    color=f_c, colorSpace='rgb', opacity=1,
    flipHoriz=False, flipVert=False,
    texRes=128, interpolate=True, depth=0.0)

# Create some handy timers
globalClock01 = core.Clock()  # to track the time since experiment started
routineTimer01 = core.CountdownTimer()  # to track time remaining of each (non-slip) routine 

#------Prepare to start Routine "init_experiment"-------
t = 0
frameN = -1

#------Prepare to start Routine "show_flash"-------
t = 0
show_flashClock01.reset()  # clock 
frameN = -1
# update component parameters for each repeat
# flash begin routine
f_change = 0

# keep track of which components have finished
show_flashComponents01 = []
show_flashComponents01.append(frame_fl)
for thisComponent in show_flashComponents01:
    if hasattr(thisComponent, 'status'):
        thisComponent.status = NOT_STARTED
########################################################################################
########################################################################################

#---Start Routine "show_flash"-------
continueRoutine = True
while continueRoutine:
#        thecount = thecount+1
#        print("The count =", thecount)
#        
#        if thecount == 1:
#            rtclock.reset() # Reset the clock here
        
    # Hides mouse
    mouse = event.Mouse(visible=0)
    
    # get current time
    t = show_flashClock01.getTime()
    #print("t =", t)
    frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
    
    # update/draw components on each frame
    #print(frameN)
    
    # *frame_fl* updates
    if t >= 0.0 and frame_fl.status == NOT_STARTED:
        # keep track of start time/frame for later
        frame_fl.tStart = t  # underestimates by a little under one frame
        frame_fl.frameNStart = frameN  # exact frame index
        frame_fl.draw()
    # flash each frame
    if frameN >= f_change:
        flash_change()
        f_change += f_t
    introtext01.draw()
    introtext019.draw()
    introtext0191.draw()
    introtext0192.draw()
    #introtext0001.draw()
    flash01.draw()  # First stimulus is drawn here
    
    # check if all components have finished
    if not continueRoutine:  # a component has requested a forced-end of Routine
        routineTimer01.reset()  # if we abort early the non-slip timer needs reset
        break
    continueRoutine = False  # will revert to True if at least one component still running
    for thisComponent in show_flashComponents01:
        if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
            continueRoutine = True
            break  # at least one component has not yet finished
    
    if event.getKeys(keyList=["space"]):
        break
    
    # refresh the screen
    if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
        win.flip()
    else:  # this Routine was not non-slip safe so reset non-slip timer
        routineTimer.reset()
    
        
#-------Ending Routine "show_flash"-------
for thisComponent in show_flashComponents01:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
########################################################################################
########################################################################################
win.flip()




########################################################################################
########################################################################################
########################################################################################
# CALIBRATION STAGE:
########################################################################################
########################################################################################
########################################################################################
# Initialize components for Routine "init_experiment"
init_experimentClock = core.Clock()
# set_colors()
# Colors used during the experiment.s
def set_colors():
    global sc_c # screen color
    global f_c # frame color
    global sq_c # square color
    # 1 = white
    # -0.06 = grey 80
    # -0.37 = grey 120
    # -1 = black
    sc_c = 1
    f_c = -0.06
    sq_c = -0.37
    t_c = -0.06

# set_sizes()
# Sizes used during the experiment
def set_sizes():
    global f_s # frame size (square) (frame surrounding the stimulus)
    global sq_s # square size (square where the stimulus is shown)
    global l_s # line size (the width of the line surrounding the stimulus)
    f_s = 540
    sq_s = 800
    l_s = 100
    
# Set the position of left stimulus
def set_positions01():
    global fl_p3 # Where should the flash be drawn
    fl_p3 = [0, 0]

########################################################################################
# Set main conditions and loop
########################################################################################

# Counter to keep track of things
counter = 0
thecount = 0
counter01 = 0
thecount01 = 0
pcounter = 1
pcounter2 = 1
pcounter_practext = 1 # Determine when to show introduction practice trials

# Get number of correct responses for the 4 different proportions:
pp1 = []
pp2 = []
pp3 = []
pp4 = []

# Keep track of number of correct responses during practice trials:
practice_correct = []*50

# Set the colour order for the calibration stage:
colour_order1 = colour_order[0]

done = 1

for j in range(infin_run):
    
    ##########################################################
    # Determine if they passed or failed practice trials text:
    ##########################################################
    
    if j is 4 or j is 8 or j is 12 or j is 16 or j is 20:
        if done == 1:
            win.flip()
            display_time = True
            if len(practice_correct) == 0:
                while display_time:
                    #win.flip()
                    zero_per.draw()
                    win.flip()
                    practice_correct = [] # Continue practice trials
                    if event.getKeys(keyList=["1"]):
                        pcounter = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        pcounter = 1
                        break
            elif len(practice_correct) == 1:
                while display_time:
                    #win.flip()
                    two_five_per.draw()
                    win.flip()
                    practice_correct = [] # Continue practice trials
                    if event.getKeys(keyList=["1"]):
                        pcounter = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        pcounter = 1
                        break
            elif len(practice_correct) == 2:
                while display_time:
                    #win.flip()
                    five_zero_per.draw()
                    win.flip()
                    practice_correct = [] # Continue practice trials
                    if event.getKeys(keyList=["1"]):
                        pcounter = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        pcounter = 1
                        break
            elif len(practice_correct) == 3:
                while display_time:
                    #win.flip()
                    seven_five_per.draw()
                    win.flip()
                    practice_correct = [] # Continue practice trials
                    if event.getKeys(keyList=["1"]):
                        pcounter = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        pcounter = 1
                        break
            elif len(practice_correct) == 4: # Participants got 100% here so can move onto experimental trials
                while display_time:
                    #win.flip()
                    zero_one_one_per.draw()
                    win.flip()
                    if event.getKeys(keyList=["1"]):
                        pcounter = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        pcounter = 1
                        break
    ##########################################################
    ##########################################################
    
    if pcounter < practicetrials_pass:
        singleconditionsx = singlegridpractice[j]
        if singleconditionsx >= 3:
            colour_order1 ==2 # ORANGE
        else:
            colour_order1 == 1 # BLUE
    else:
        # Select what condition is to be performed on experimental trials:
        singleconditionsx = singleconditions_calibration[counter01]
    
    
    # Set the experimental conditions here:
    # Blue colours:
    if singleconditionsx == 1:
        p01 = hard_proportion#(48/52)
    elif singleconditionsx == 2:
        p01 = .65#(65/35)
    # Orange colours:
    elif singleconditionsx == 3:
        p01 = hard_proportion#(48/52)
    elif singleconditionsx == 4:
        p01 = .65#(65/35)
        
    
    # THE ACTUAL CALIBRATION TRIALS (we're manipulating orange here):
    # More BLUE trials:
    elif singleconditionsx == 10:
        p01 = .49 # (51/49)
    elif singleconditionsx == 20:
        p01 = .48 # (52/48)
    elif singleconditionsx == 30:
        p01 = .47 # (53/47)
    elif singleconditionsx == 40:
        p01 = .46 # (54/46)
    # More ORANGE trials:
    elif singleconditionsx == 50:
        p01 = .51 # (51/49)
    elif singleconditionsx == 60:
        p01 = .52 # (52/48)
    elif singleconditionsx == 70:
        p01 = .53 # (53/47)
    elif singleconditionsx == 80:
        p01 = .54 # (54/46)
    
    
    # flash stimulus functions
    # flash initialization
    def flash_init(win, position01=[0,0], square_size=10, columns=20, rows=20, percent_color01=p01): # Colour2 being manipulated whic is BLUE
        global flash01 # The flash stimulus (an array of flashing squares)
        
        if singleconditionsx <= 2:
            color_set01 = [color2, color1] # color2 is being manipulated which is the BLUE
        elif singleconditionsx >= 3:
            color_set01 = [color1, color2] # colour1 is being manipulated which is the ORANGE
        cell_number = columns * rows
    
        num_color4 = int(np.floor(float(cell_number)*percent_color01)) # First colour
        num_color5 = int(np.floor(float(cell_number)*(1-percent_color01))) # Second colour
        
        # fill an array with colors. Each color should appear approximatively the same number of times.
        f_colors3 = []
        for i in range(num_color4):
            f_colors3.append(color_set01[0])
        for i in range(num_color5):
            f_colors3.append(color_set01[1])
        numpy.random.shuffle(color_set01)
        i = cell_number - len(f_colors3)
        while i > 0:
            f_colors3.append(color_set01[i])
            i -= 1
        
        # randomize color order.
        shuffle(f_colors3)
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys.append((x_left + c * square_size, y_top + l * square_size))
        
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys2 = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys2.append((x_left + c * square_size, y_top + l * square_size))
        
        # MAIN FUNCTION TO CREATE FIRST GRID
        flash01 = visual.ElementArrayStim(win=win,
                            fieldPos=position01,
                            fieldShape='sqr',
                            nElements=cell_number,
                            sizes=square_size,
                            xys=xys,
                            colors=f_colors3,
                            elementTex=None,
                            elementMask=None,
                            name='flash',
                            autoLog=False)
                            
                            
                            
    
    # flash stimulus change
    def flash_change():
        global flash01
        shuffle(flash01.colors)
        flash01.setColors(flash01.colors)
    
    # Time variables used during the experiment
    def set_timing():
        global f_t 
        f_t = 5 # The duration (in frame) of a flash image presentation
    
    # data_init
    set_colors()
    set_sizes()
    set_positions01()
    set_timing()
    
    #############################
    # MAIN FUNCTION HERE
    flash_init(win, fl_p3, square_size=0.3, columns=20, rows=20) # set the parameters here for the function!!
    #############################
    
    # Initialize components for Routine "show_flash"
    show_flashClock01 = core.Clock()
    frame_fl = visual.ImageStim(win=win, name='frame_fl',
        image=None, mask=None,
        ori=0, pos=fl_p3, size=f_s,
        color=f_c, colorSpace='rgb', opacity=1,
        flipHoriz=False, flipVert=False,
        texRes=128, interpolate=True, depth=0.0)
    
    # Create some handy timers
    globalClock01 = core.Clock()  # to track the time since experiment started
    routineTimer01 = core.CountdownTimer()  # to track time remaining of each (non-slip) routine 
    
    #------Prepare to start Routine "init_experiment"-------
    t = 0
    frameN = -1
    
    #------Prepare to start Routine "show_flash"-------
    t = 0
    show_flashClock01.reset()  # clock 
    frameN = -1
    # update component parameters for each repeat
    # flash begin routine
    f_change = 0
    
    # keep track of which components have finished
    show_flashComponents01 = []
    show_flashComponents01.append(frame_fl)
    for thisComponent in show_flashComponents01:
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    ########################################################################################
    ########################################################################################
    
    
    ########################################################################################
    # MAIN EXPERIMENT
    ########################################################################################
    
    
    
    
    #######################################
    #######################################
    # Start of trial text:
    #######################################
    #######################################
    
    # Practice trial text: 
    if pcounter_practext == 1:
        if colour_order1 == 1:
            win.flip()
            single_blue.draw()
            key_press.draw()
            win.flip()
            keypressed = event.waitKeys(timeStamped=False)
            checkclock01.reset()
        elif colour_order1 == 2:
            win.flip()
            single_orange.draw()
            key_press.draw()
            win.flip()
            keypressed = event.waitKeys(timeStamped=False)
            checkclock01.reset()
                   
    # Experimental trial text:
    if pcounter == 2:
        if colour_order1 == 1:
            win.flip()
            endspractice_bf.draw()
            endspractice_b1.draw()
            key_press.draw()
            win.flip()
        elif colour_order1 == 2:
            win.flip()
            endspractice_of.draw()
            endspractice_o1.draw()
            key_press.draw()
            win.flip()
        keypressed = event.waitKeys(timeStamped=False)
        checkclock01.reset() 
    
    #######################################
    #######################################
    
    
    
    
    #---Start Routine "show_flash"-------
    continueRoutine = True
    while continueRoutine:
            
        # Hides mouse
        mouse = event.Mouse(visible=0)
        
        # get current time
        t = show_flashClock01.getTime()
        #print("t =", t)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        
        # update/draw components on each frame
        #print(frameN)
        
        # *frame_fl* updates
        if t >= 0.0 and frame_fl.status == NOT_STARTED:
            # keep track of start time/frame for later
            frame_fl.tStart = t  # underestimates by a little under one frame
            frame_fl.frameNStart = frameN  # exact frame index
            frame_fl.draw()
        # flash each frame
        if frameN >= f_change:
            flash_change()
            f_change += f_t
#        if colour_order1 == 1:
#            strialtextb.draw()
#        elif colour_order1 == 2:
            #strialtexto.draw()
        flash01.draw()  # First stimulus is drawn here
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineTimer01.reset()  # if we abort early the non-slip timer needs reset
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in show_flashComponents01:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
                
        # PRACTICE TRIALS:
        if pcounter < practicetrials_pass:
            pcounter_practext = pcounter_practext+1
            if event.getKeys(keyList=["6"]):
                win.close()
                core.quit()
            if event.getKeys(keyList=["z"]):
                if colour_order1 == 1: # BLUE
                    if singleconditionsx is 1 or singleconditionsx is 2:
                        win.flip()
                        correct_res.draw()
                        win.flip()
                        practice_correct.append('1') # Keep track of the number of correct practice trial responses here
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                    else:
                        win.flip()
                        incorrect_res.draw()
                        win.flip()
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                elif colour_order1 == 2: # ORANGE
                    if singleconditionsx is 3 or singleconditionsx is 4:
                        win.flip()
                        correct_res.draw()
                        win.flip()
                        practice_correct.append('1') # Keep track of the number of correct practice trial responses here
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                    else:
                        win.flip()
                        incorrect_res.draw()
                        win.flip()
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                event.clearEvents(eventType='keyboard')
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock01.reset()
                event.clearEvents(eventType='keyboard')
                break
            elif event.getKeys(keyList=["m"]):
                if colour_order1 == 1: # BLUE
                    if singleconditionsx is 3 or singleconditionsx is 4:
                        win.flip()
                        correct_res.draw()
                        win.flip()
                        practice_correct.append('1') # Keep track of the number of correct practice trial responses here
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                    else:
                        win.flip()
                        incorrect_res.draw()
                        win.flip()
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                elif colour_order1 == 2: # ORANGE
                    if singleconditionsx is 1 or singleconditionsx is 2:
                        win.flip()
                        correct_res.draw()
                        win.flip()
                        practice_correct.append('1') # Keep track of the number of correct practice trial responses here
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                    else:
                        win.flip()
                        incorrect_res.draw()
                        win.flip()
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                event.clearEvents(eventType='keyboard')
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock01.reset()
                event.clearEvents(eventType='keyboard')
                break
        # EXPERIMENTAL TRIALS:
        elif pcounter >= practicetrials_pass:
            # RESPONSE 1:
            if event.getKeys(keyList=["escape"]):
                win.flip()
                breaktext.draw()
                win.flip()
                keypressed = event.waitKeys(timeStamped=False)
                checkclock01.reset()
            if event.getKeys(keyList=["6"]):
                win.close()
                core.quit()
            if event.getKeys(keyList=["z"]): # MORE key
            
                # Update practice trial counter
                pcounter = pcounter+1
                
                # More BLUE:
                if colour_order1 == 1:
                    if singleconditionsx == 10:
                        pp1.append('1')
                    elif singleconditionsx == 20:
                        pp2.append('1')
                    elif singleconditionsx == 30:
                        pp3.append('1')
                    elif singleconditionsx == 40:
                        pp4.append('1')
                # More ORANGE:
                elif colour_order1 == 2:
                    if singleconditionsx == 50:
                        pp1.append('1')
                    elif singleconditionsx == 60:
                        pp2.append('1')
                    elif singleconditionsx == 70:
                        pp3.append('1')
                    elif singleconditionsx == 80:
                        pp4.append('1')
                        
                        
                # Update the counter
                counter01 = counter01+1
                
                # DRAW FIXATION CROSS AFTER EACH TRIAL
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                event.clearEvents(eventType='keyboard')
                
                # END THE EXPERIMENT HERE AND SAVE DATA
                if counter01 == cali_trials:
                    win.flip() # Clears the window
                    endtext01.draw() # Draw ending message here
                    endtext010.draw()
                    win.flip() # Clears the window
                    keypressed = event.waitKeys(timeStamped=False)
                    ###############################################
                    # CALCULATE PROPORTION RESULTS AND DEFINE TEXT:
                    ###############################################
                    proportion1 = len(pp1)/6
                    proportion2 = len(pp2)/6
                    proportion3 = len(pp3)/6
                    proportion4 = len(pp4)/6
                    p1_text = str(proportion1)
                    pro1_text = visual.TextStim(win, text=p1_text, pos=(0,4), height=textsize, wrapWidth=30, alignHoriz = 'center')
                    p2_text = str(proportion2)
                    pro2_text = visual.TextStim(win, text=p2_text, pos=(0,2), height=textsize, wrapWidth=30, alignHoriz = 'center')
                    p3_text = str(proportion3)
                    pro3_text = visual.TextStim(win, text=p3_text, pos=(0,0), height=textsize, wrapWidth=30, alignHoriz = 'center')
                    p4_text = str(proportion4)
                    pro4_text = visual.TextStim(win, text=p4_text, pos=(0,-2), height=textsize, wrapWidth=30, alignHoriz = 'center')
                    ###############################################
                    ###############################################
                    # Show proportion text:
                    win.flip()
                    pro1_text.draw()
                    pro2_text.draw()
                    pro3_text.draw()
                    pro4_text.draw()
                    win.flip()
                    keypressed = event.waitKeys(timeStamped=False)
                break # End the expriment
                
             # RESPONSE 2: (Right Side)
            if event.getKeys(keyList=["m"]): # LESS key
                
                
                # Update practice trial counter
                pcounter = pcounter+1
                
                # More BLUE:
                if colour_order1 == 1:
                    if singleconditionsx == 50:
                        pp1.append('1')
                    elif singleconditionsx == 60:
                        pp2.append('1')
                    elif singleconditionsx == 70:
                        pp3.append('1')
                    elif singleconditionsx == 80:
                        pp4.append('1')
                if colour_order1 == 2:
                    if singleconditionsx == 10:
                        pp1.append('1')
                    elif singleconditionsx == 20:
                        pp2.append('1')
                    elif singleconditionsx == 30:
                        pp3.append('1')
                    elif singleconditionsx == 40:
                        pp4.append('1')
                        
                        
                # Update the counter
                counter01 = counter01+1
                
                # DRAW FIXATION CROSS AFTER EACH TRIAL
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                event.clearEvents(eventType='keyboard')
                
                # END THE EXPERIMENT HERE AND SAVE DATA
                if counter01 == cali_trials:
                    win.flip() # Clears the window
                    endtext01.draw() # Draw ending message here
                    endtext010.draw()
                    win.flip() # Clears the window
                    keypressed = event.waitKeys(timeStamped=False)
                    ###############################################
                    # CALCULATE PROPORTION RESULTS AND DEFINE TEXT:
                    ###############################################
                    proportion1 = len(pp1)/6
                    proportion2 = len(pp2)/6
                    proportion3 = len(pp3)/6
                    proportion4 = len(pp4)/6
                    p1_text = str(proportion1)
                    pro1_text = visual.TextStim(win, text=p1_text, pos=(0,4), height=textsize, wrapWidth=30, alignHoriz = 'center')
                    p2_text = str(proportion2)
                    pro2_text = visual.TextStim(win, text=p2_text, pos=(0,2), height=textsize, wrapWidth=30, alignHoriz = 'center')
                    p3_text = str(proportion3)
                    pro3_text = visual.TextStim(win, text=p3_text, pos=(0,0), height=textsize, wrapWidth=30, alignHoriz = 'center')
                    p4_text = str(proportion4)
                    pro4_text = visual.TextStim(win, text=p4_text, pos=(0,-2), height=textsize, wrapWidth=30, alignHoriz = 'center')
                    ###############################################
                    ###############################################
                    # Show proportion text:
                    win.flip()
                    pro1_text.draw()
                    pro2_text.draw()
                    pro3_text.draw()
                    pro4_text.draw()
                    win.flip()
                    keypressed = event.waitKeys(timeStamped=False)
                break # End the expriment
            
            
            
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
        else:  # this Routine was not non-slip safe so reset non-slip timer
            routineTimer.reset()
        
        # END THE EXPERIMENT HERE
        if counter01 == cali_trials:
            win.flip() # Clears the window
            endtext01.draw() # Draw ending message here
            endtext010.draw()
            win.flip() # Clears the window
            keypressed = event.waitKeys(timeStamped=False)
            ###############################################
            # CALCULATE PROPORTION RESULTS AND DEFINE TEXT:
            ###############################################
            proportion1 = len(pp1)/6
            proportion2 = len(pp2)/6
            proportion3 = len(pp3)/6
            proportion4 = len(pp4)/6
            p1_text = str(proportion1)
            pro1_text = visual.TextStim(win, text=p1_text, pos=(0,4), height=textsize, wrapWidth=30, alignHoriz = 'center')
            p2_text = str(proportion2)
            pro2_text = visual.TextStim(win, text=p2_text, pos=(0,2), height=textsize, wrapWidth=30, alignHoriz = 'center')
            p3_text = str(proportion3)
            pro3_text = visual.TextStim(win, text=p3_text, pos=(0,0), height=textsize, wrapWidth=30, alignHoriz = 'center')
            p4_text = str(proportion4)
            pro4_text = visual.TextStim(win, text=p4_text, pos=(0,-2), height=textsize, wrapWidth=30, alignHoriz = 'center')
            ###############################################
            ###############################################
            # Show proportion text:
            win.flip()
            pro1_text.draw()
            pro2_text.draw()
            pro3_text.draw()
            pro4_text.draw()
            win.flip()
            keypressed = event.waitKeys(timeStamped=False)
            break
    if counter01 == cali_trials:
        break
            
#-------Ending Routine "show_flash"-------
for thisComponent in show_flashComponents01:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
########################################################################################
########################################################################################









########################################################################################
########################################################################################
########################################################################################
# Single Grid Trials - First Block:
########################################################################################
########################################################################################
########################################################################################
# Initialize components for Routine "init_experiment"
init_experimentClock = core.Clock()
# set_colors()
# Colors used during the experiment.s
def set_colors():
    global sc_c # screen color
    global f_c # frame color
    global sq_c # square color
    # 1 = white
    # -0.06 = grey 80
    # -0.37 = grey 120
    # -1 = black
    sc_c = 1
    f_c = -0.06
    sq_c = -0.37
    t_c = -0.06

# set_sizes()
# Sizes used during the experiment
def set_sizes():
    global f_s # frame size (square) (frame surrounding the stimulus)
    global sq_s # square size (square where the stimulus is shown)
    global l_s # line size (the width of the line surrounding the stimulus)
    f_s = 540
    sq_s = 800
    l_s = 100
    
# Set the position of left stimulus
def set_positions01():
    global fl_p3 # Where should the flash be drawn
    fl_p3 = [0, 0]

########################################################################################
# Set main conditions and loop
########################################################################################

# Counter to keep track of things
counter = 0
thecount = 0
counter01 = 0
thecount01 = 0
pcounter = 1
pcounter2 = 1
pcounter_practext = 1 # Determine when to show introduction practice trials

# Keep track of number of correct responses during practice trials:
practice_correct = []*50

# Set the colour order for the first colour block:
colour_order1 = colour_order[0]

done = 1

for j in range(infin_run):
    
    ##########################################################
    # Determine if they passed or failed practice trials text:
    ##########################################################
    
    print('length of practice_correct ===', practice_correct)
    if j is 4 or j is 8 or j is 12 or j is 16 or j is 20:
        if done == 1:
            win.flip()
            display_time = True
            if len(practice_correct) == 0:
                while display_time:
                    #win.flip()
                    zero_per.draw()
                    win.flip()
                    practice_correct = [] # Continue practice trials
                    if event.getKeys(keyList=["1"]):
                        pcounter = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        pcounter = 1
                        break
            elif len(practice_correct) == 1:
                while display_time:
                    #win.flip()
                    two_five_per.draw()
                    win.flip()
                    practice_correct = [] # Continue practice trials
                    if event.getKeys(keyList=["1"]):
                        pcounter = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        pcounter = 1
                        break
            elif len(practice_correct) == 2:
                while display_time:
                    #win.flip()
                    five_zero_per.draw()
                    win.flip()
                    practice_correct = [] # Continue practice trials
                    if event.getKeys(keyList=["1"]):
                        pcounter = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        pcounter = 1
                        break
            elif len(practice_correct) == 3:
                while display_time:
                    #win.flip()
                    seven_five_per.draw()
                    win.flip()
                    practice_correct = [] # Continue practice trials
                    if event.getKeys(keyList=["1"]):
                        pcounter = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        pcounter = 1
                        break
            elif len(practice_correct) == 4: # Participants got 100% here so can move onto experimental trials
                while display_time:
                    #win.flip()
                    zero_one_one_per.draw()
                    win.flip()
                    if event.getKeys(keyList=["1"]):
                        pcounter = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        pcounter = 1
                        break
    ##########################################################
    ##########################################################
    
    print('jjjjjjj',j)
    if pcounter < practicetrials_pass:
        singleconditionsx = singlegridpractice[j]
        print('single practice trial',singleconditionsx)
        if singleconditionsx >= 3:
            colour_order1 ==2 # ORANGE
        else:
            colour_order1 == 1 # BLUE
    else:
        # Select what condition is to be performed on experimental trials:
        if colour_order1 == 1: # BLUE
            singleconditionsx = singleconditions_all[counter01]
        elif colour_order1 == 2: # ORANGE
            singleconditionsx = singleconditions_all[counter01]
    
    
    if pcounter >= practicetrials_pass:
        # Append the condition we're on:
        if singleconditionsx == 1:
            conused.append('b,o')
            difflevel.append('Exp - Hard 1')
        elif singleconditionsx == 2:
            conused.append('B,o')
            difflevel.append('Con - Easy 1')
        elif singleconditionsx == 3:
            conused.append('o,b')
            difflevel.append('Exp - Hard 1')
        elif singleconditionsx == 4:
            conused.append('O,b')
            difflevel.append('Con - Easy 1')
    
    # Set the conditions here:
    # Blue colours:
    if singleconditionsx == 1:
        p01 = hard_proportion#(48/52)
    elif singleconditionsx == 2:
        p01 = .65#(65/35)
    # Orange colours:
    elif singleconditionsx == 3:
        p01 = hard_proportion#(48/52)
    elif singleconditionsx == 4:
        p01 = .65#(65/35)
        
        
        
    # flash stimulus functions
    # flash initialization
    def flash_init(win, position01=[0,0], square_size=10, columns=20, rows=20, percent_color01=p01): # Colour2 being manipulated whic is BLUE
        global flash01 # The flash stimulus (an array of flashing squares)
        
        if singleconditionsx <= 2:
            color_set01 = [color2, color1] # color2 is being manipulated which is the BLUE
        elif singleconditionsx >= 3:
            color_set01 = [color1, color2] # colour1 is being manipulated which is the ORANGE
        cell_number = columns * rows
    
        num_color4 = int(np.floor(float(cell_number)*percent_color01)) # First colour
        num_color5 = int(np.floor(float(cell_number)*(1-percent_color01))) # Second colour
        
        # fill an array with colors. Each color should appear approximatively the same number of times.
        f_colors3 = []
        for i in range(num_color4):
            f_colors3.append(color_set01[0])
        for i in range(num_color5):
            f_colors3.append(color_set01[1])
        numpy.random.shuffle(color_set01)
        i = cell_number - len(f_colors3)
        while i > 0:
            f_colors3.append(color_set01[i])
            i -= 1
        
        # randomize color order.
        shuffle(f_colors3)
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys.append((x_left + c * square_size, y_top + l * square_size))
        
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys2 = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys2.append((x_left + c * square_size, y_top + l * square_size))
        
        # MAIN FUNCTION TO CREATE FIRST GRID
        flash01 = visual.ElementArrayStim(win=win,
                            fieldPos=position01,
                            fieldShape='sqr',
                            nElements=cell_number,
                            sizes=square_size,
                            xys=xys,
                            colors=f_colors3,
                            elementTex=None,
                            elementMask=None,
                            name='flash',
                            autoLog=False)
                            
                            
                            
    
    # flash stimulus change
    def flash_change():
        global flash01
        shuffle(flash01.colors)
        flash01.setColors(flash01.colors)
    
    # Time variables used during the experiment
    def set_timing():
        global f_t 
        f_t = 5 # The duration (in frame) of a flash image presentation
    
    # data_init
    set_colors()
    set_sizes()
    set_positions01()
    set_timing()
    
    #############################
    # MAIN FUNCTION HERE
    flash_init(win, fl_p3, square_size=0.3, columns=20, rows=20) # set the parameters here for the function!!
    #############################
    
    # Initialize components for Routine "show_flash"
    show_flashClock01 = core.Clock()
    frame_fl = visual.ImageStim(win=win, name='frame_fl',
        image=None, mask=None,
        ori=0, pos=fl_p3, size=f_s,
        color=f_c, colorSpace='rgb', opacity=1,
        flipHoriz=False, flipVert=False,
        texRes=128, interpolate=True, depth=0.0)
    
    # Create some handy timers
    globalClock01 = core.Clock()  # to track the time since experiment started
    routineTimer01 = core.CountdownTimer()  # to track time remaining of each (non-slip) routine 
    
    #------Prepare to start Routine "init_experiment"-------
    t = 0
    frameN = -1
    
    #------Prepare to start Routine "show_flash"-------
    t = 0
    show_flashClock01.reset()  # clock 
    frameN = -1
    # update component parameters for each repeat
    # flash begin routine
    f_change = 0
    
    # keep track of which components have finished
    show_flashComponents01 = []
    show_flashComponents01.append(frame_fl)
    for thisComponent in show_flashComponents01:
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    ########################################################################################
    ########################################################################################
    
    
    ########################################################################################
    # MAIN EXPERIMENT
    ########################################################################################
    
    
    
    
    #######################################
    #######################################
    # Start of trial text:
    #######################################
    #######################################
    
    # Practice trial text: 
    if pcounter_practext == 1:
        if colour_order1 == 1:
            win.flip()
            single_blue.draw()
            key_press.draw()
            win.flip()
            keypressed = event.waitKeys(timeStamped=False)
            checkclock01.reset()
        elif colour_order1 == 2:
            win.flip()
            single_orange.draw()
            key_press.draw()
            win.flip()
            keypressed = event.waitKeys(timeStamped=False)
            checkclock01.reset()
                   
    # Experimental trial text:
    if pcounter == 2:
        if colour_order1 == 1:
            win.flip()
            endspractice_b1.draw()
            endspractice_b2.draw()
            endspractice_bf.draw()
            win.flip()
        elif colour_order1 == 2:
            win.flip()
            endspractice_o1.draw()
            endspractice_o2.draw()
            endspractice_of.draw()
            win.flip()
        keypressed = event.waitKeys(timeStamped=False)
        checkclock01.reset() 
    
    #######################################
    #######################################
    
    
    
    
    #---Start Routine "show_flash"-------
    continueRoutine = True
    while continueRoutine:
            
        # Hides mouse
        mouse = event.Mouse(visible=0)
        
        # get current time
        t = show_flashClock01.getTime()
        #print("t =", t)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        
        # update/draw components on each frame
        #print(frameN)
        
        # *frame_fl* updates
        if t >= 0.0 and frame_fl.status == NOT_STARTED:
            # keep track of start time/frame for later
            frame_fl.tStart = t  # underestimates by a little under one frame
            frame_fl.frameNStart = frameN  # exact frame index
            frame_fl.draw()
        # flash each frame
        if frameN >= f_change:
            flash_change()
            f_change += f_t
#        if colour_order1 == 1:
#            strialtextb.draw()
#        elif colour_order1 == 2:
            #strialtexto.draw()
        flash01.draw()  # First stimulus is drawn here
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineTimer01.reset()  # if we abort early the non-slip timer needs reset
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in show_flashComponents01:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
                
        # PRACTICE TRIALS:
        if pcounter < practicetrials_pass:
            pcounter_practext = pcounter_practext+1
            if event.getKeys(keyList=["6"]):
                win.close()
                core.quit()
            if event.getKeys(keyList=["z"]):
                if colour_order1 == 1: # BLUE
                    if singleconditionsx is 1 or singleconditionsx is 2:
                        win.flip()
                        correct_res.draw()
                        win.flip()
                        practice_correct.append('1') # Keep track of the number of correct practice trial responses here
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                    else:
                        win.flip()
                        incorrect_res.draw()
                        win.flip()
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                elif colour_order1 == 2: # ORANGE
                    if singleconditionsx is 3 or singleconditionsx is 4:
                        win.flip()
                        correct_res.draw()
                        win.flip()
                        practice_correct.append('1') # Keep track of the number of correct practice trial responses here
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                    else:
                        win.flip()
                        incorrect_res.draw()
                        win.flip()
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                event.clearEvents(eventType='keyboard')
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock01.reset()
                event.clearEvents(eventType='keyboard')
                break
            elif event.getKeys(keyList=["m"]):
                if colour_order1 == 1: # BLUE
                    if singleconditionsx is 3 or singleconditionsx is 4:
                        win.flip()
                        correct_res.draw()
                        win.flip()
                        practice_correct.append('1') # Keep track of the number of correct practice trial responses here
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                    else:
                        win.flip()
                        incorrect_res.draw()
                        win.flip()
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                elif colour_order1 == 2: # ORANGE
                    if singleconditionsx is 1 or singleconditionsx is 2:
                        win.flip()
                        correct_res.draw()
                        win.flip()
                        practice_correct.append('1') # Keep track of the number of correct practice trial responses here
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                    else:
                        win.flip()
                        incorrect_res.draw()
                        win.flip()
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                event.clearEvents(eventType='keyboard')
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock01.reset()
                event.clearEvents(eventType='keyboard')
                break
        # EXPERIMENTAL TRIALS:
        elif pcounter >= practicetrials_pass:
            # RESPONSE 1:
            if event.getKeys(keyList=["escape"]):
                win.flip()
                breaktext.draw()
                win.flip()
                keypressed = event.waitKeys(timeStamped=False)
                checkclock01.reset()
            if event.getKeys(keyList=["6"]):
                win.close()
                core.quit()
            if event.getKeys(keyList=["z"]): # MORE key
            
                # Update practice trial counter
                pcounter = pcounter+1
                
                # print the condition we did
                print("actual single trial done =", singleconditionsx)
                
                # Track response times
                #rt = rtclock.getTime()
                time01 = checkclock01.getTime()
                RT.append(time01)
                
                if colour_order1 == 1:
                    if singleconditionsx <= 2:
                        correctresponse.append('1')
                        print('response ===========  correct')
                    elif singleconditionsx >= 3:
                        correctresponse.append('0')
                        print('response ===========  incorrect')
                elif colour_order1 == 2:
                    if singleconditionsx <= 2:
                        correctresponse.append('0')
                        print('response ===========  incorrect')
                    elif singleconditionsx >= 3:
                        correctresponse.append('1')
                        print('response ===========  correct')
                # Append which colour question was being asked:
                colourcolour1.append(colour_order1)
                
                # Keep track of keys pressed
                keyspressed.append('left')
                
                # Update the counter
                counter01 = counter01+1
                
                # Keep track of trial number to be saved 
                trialNo.append(counter01)
                
                
                # DRAW FIXATION CROSS AFTER EACH TRIAL
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock01.reset()
                event.clearEvents(eventType='keyboard')
                
                # END THE EXPERIMENT HERE AND SAVE DATA
                if counter01 == singletrials:
                    win.flip() # Clears the window
                    endtext01.draw() # Draw ending message here
                    endtext010.draw()
                    win.flip() # Clears the window
                    keypressed = event.waitKeys(timeStamped=False)
                break # End the expriment
                
             # RESPONSE 2: (Right Side)
            if event.getKeys(keyList=["m"]): # LESS key
                
                
                # Update practice trial counter
                pcounter = pcounter+1
                
                # print the condition we did
                print("actual single trial done =", singleconditionsx)
                
                time01 = checkclock01.getTime()
                RT.append(time01)
                
                if colour_order1 == 1:
                    if singleconditionsx <= 2:
                        correctresponse.append('0')
                        print('response ===========  incorrect')
                    elif singleconditionsx >= 3:
                        correctresponse.append('1')
                        print('response ===========  correct')
                elif colour_order1 == 2:
                    if singleconditionsx <= 2:
                        correctresponse.append('1')
                        print('response ===========  correct')
                    elif singleconditionsx >= 3:
                        correctresponse.append('0')
                        print('response ===========  incorrect')
                # Append which colour question was being asked:
                colourcolour1.append(colour_order1)
                
                # Keep track of keys pressed
                keyspressed.append('right')
                
                # Update the counter
                counter01 = counter01+1
                
                # Keep track of trial number to be saved 
                trialNo.append(counter01)
                
                
                # DRAW FIXATION CROSS AFTER EACH TRIAL
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock01.reset()
                event.clearEvents(eventType='keyboard')
                
                # END THE EXPERIMENT HERE AND SAVE DATA
                if counter01 == singletrials:
                    win.flip() # Clears the window
                    endtext01.draw() # Draw ending message here
                    endtext010.draw()
                    win.flip() # Clears the window
                    keypressed = event.waitKeys(timeStamped=False)
                break # End the expriment
            
            
            
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
        else:  # this Routine was not non-slip safe so reset non-slip timer
            routineTimer.reset()
        
        # END THE EXPERIMENT HERE
        if counter01 == singletrials:
            win.flip() # Clears the window
            endtext01.draw() # Draw ending message here
            endtext010.draw()
            win.flip() # Clears the window
            keypressed = event.waitKeys(timeStamped=False)
            break
    if counter01 == singletrials:
        break
            
#-------Ending Routine "show_flash"-------
for thisComponent in show_flashComponents01:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
########################################################################################
########################################################################################









########################################################################################
########################################################################################
########################################################################################
# Paired Grid Trials INTRODUCTION:
########################################################################################
########################################################################################
########################################################################################
# Initialize components for Routine "init_experiment"
init_experimentClock = core.Clock()
# set_colors()
# Colors used during the experiment.s
def set_colors():
    global sc_c # screen color
    global f_c # frame color
    global sq_c # square color
    # 1 = white
    # -0.06 = grey 80
    # -0.37 = grey 120
    # -1 = black
    sc_c = 1
    f_c = -0.06
    sq_c = -0.37
    t_c = -0.06

# set_sizes()
# Sizes used during the experiment
def set_sizes():
    global f_s # frame size (square) (frame surrounding the stimulus)
    global sq_s # square size (square where the stimulus is shown)
    global l_s # line size (the width of the line surrounding the stimulus)
    f_s = 540
    sq_s = 800
    l_s = 100


########################################################################################
########################################################################################

########################################################################################
# Set main conditions and loop
########################################################################################
for i in range(1):
     
    p1=.35
    p2=.48

    leftside  = [-6,-5]
    rightside = [6,-5]
    
    
    # Set the position of left stimulus
    def set_positions():
        global fl_p # Where should the flash be drawn
        fl_p = leftside
            
    # Set the position of right stimulus
    def set_positions2():
        global fl_p2 # Where should the flash be drawn
        fl_p2 = rightside
        
    # flash stimulus functions
    # flash initialization
    def flash_init(win, position=[0,0], position2=[0,0], square_size=10, columns=20, rows=20, percent_color1=p1, percent_color2=p2): # Colour 1 being manipulated
        global flash # The flash stimulus (an array of flashing squares)
        global flash2

        color_set = [color2, color1]   # Orange
        color_set2 = [color2, color1]  # Orange
        cell_number = columns * rows
    
        num_color1 = int(np.floor(float(cell_number)*percent_color1)) # First colour
        num_color2 = int(np.floor(float(cell_number)*(1-percent_color1))) # Second f
    
        num_color3 = int(np.floor(float(cell_number)*percent_color2)) # First colour
        num_color4 = int(np.floor(float(cell_number)*(1-percent_color2))) # Second f
        
        #print(cell_number,num_color1,num_color2)
        
        # fill an array with colors. Each color should appear approximatively the same number of times.
        f_colors = []
        for i in range(num_color1):
            f_colors.append(color_set[0])
        for i in range(num_color2):
            f_colors.append(color_set[1])
        numpy.random.shuffle(color_set)
        i = cell_number - len(f_colors)
        while i > 0:
            f_colors.append(color_set[i])
            i -= 1
        
        f_colors2 = []
        for i in range(num_color3):
            f_colors2.append(color_set2[0])
        for i in range(num_color4):
            f_colors2.append(color_set2[1])
        numpy.random.shuffle(color_set2)
        i = cell_number - len(f_colors2)
        while i > 0:
            f_colors2.append(color_set2[i])
            i -= 1
        
        # randomize color order.
        shuffle(f_colors)
        shuffle(f_colors2)
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys.append((x_left + c * square_size, y_top + l * square_size))
        
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys2 = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys2.append((x_left + c * square_size, y_top + l * square_size))
        
        # MAIN FUNCTION TO CREATE FIRST GRID
        flash = visual.ElementArrayStim(win=win,
                            fieldPos=position,
                            fieldShape='sqr',
                            nElements=cell_number,
                            sizes=square_size,
                            xys=xys,
                            colors=f_colors,
                            elementTex=None,
                            elementMask=None,
                            name='flash',
                            autoLog=False)
                            
        # MAIN FUNCTION TO CREATE SECOND GRID
        flash2 = visual.ElementArrayStim(win=win,
                        fieldPos=position2,
                        fieldShape='sqr',
                        nElements=cell_number,
                        sizes=square_size,
                        xys=xys2,
                        colors=f_colors2,
                        elementTex=None,
                        elementMask=None,
                        name='flash',
                        autoLog=False)
                            
                            
    
    # flash stimulus change
    def flash_change():
        global flash
        shuffle(flash.colors)
        flash.setColors(flash.colors)
    
    def flash2_change():
        global flash2
        shuffle(flash2.colors)
        flash2.setColors(flash2.colors)
    
    # Time variables used during the experiment
    def set_timing():
        global f_t 
        f_t = 5 # The duration (in frame) of a flash image presentation
    
    # data_init
    set_colors()
    set_sizes()
    set_positions()
    set_positions2()
    set_timing()
    
    #############################
    # MAIN FUNCTION HERE
    flash_init(win, fl_p, fl_p2, square_size=0.3, columns=20, rows=20) # set the parameters here for the function!!
    #############################
    
    # Initialize components for Routine "show_flash"
    show_flashClock = core.Clock()
    frame_fl = visual.ImageStim(win=win, name='frame_fl',
        image=None, mask=None,
        ori=0, pos=fl_p, size=f_s,
        color=f_c, colorSpace='rgb', opacity=1,
        flipHoriz=False, flipVert=False,
        texRes=128, interpolate=True, depth=0.0)
    
    # Create some handy timers
    globalClock = core.Clock()  # to track the time since experiment started
    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine 
    
    #------Prepare to start Routine "init_experiment"-------
    t = 0
    frameN = -1
    
    #------Prepare to start Routine "show_flash"-------
    t = 0
    show_flashClock.reset()  # clock 
    frameN = -1
    # update component parameters for each repeat
    # flash begin routine
    f_change = 0
    
    # keep track of which components have finished
    show_flashComponents = []
    show_flashComponents.append(frame_fl)
    for thisComponent in show_flashComponents:
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    ########################################################################################
    ########################################################################################

    #---Start Routine "show_flash"-------
    continueRoutine = True
    while continueRoutine:
        # Hides mouse
        mouse = event.Mouse(visible=0)
        
        # get current time
        t = show_flashClock.getTime()
        #print("t =", t)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        
        # update/draw components on each frame
        #print(frameN)
        
        # *frame_fl* updates
        if t >= 0.0 and frame_fl.status == NOT_STARTED:
            # keep track of start time/frame for later
            frame_fl.tStart = t  # underestimates by a little under one frame
            frame_fl.frameNStart = frameN  # exact frame index
            frame_fl.draw()
        # flash each frame
        if frameN >= f_change:
            flash_change()
            flash2_change()
            f_change += f_t
        
        section2practice22i.draw() # Draw ending message here
        section2practice22ii.draw() # Draw ending message here
        section2practice22iii.draw() # Draw ending message here
        section2practice22iiii.draw() # Draw ending message here
        flash.draw()  # First stimulus is drawn here
        flash2.draw() # Second stimulus is drawn here
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineTimer.reset()  # if we abort early the non-slip timer needs reset
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in show_flashComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        if event.getKeys(keyList=["space"]):
            break
        
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
        else:  # this Routine was not non-slip safe so reset non-slip timer
            routineTimer.reset()
            
#-------Ending Routine "show_flash"-------
for thisComponent in show_flashComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)

#win.flip()
#practicetext1q.draw()
#practicetext1qq.draw()
#win.flip()
#keypressed = event.waitKeys(timeStamped=False)

colour_order1 = colour_order[0]

if colour_order1 == 1:
    win.flip()
    paired_blue.draw()
    key_press.draw()
    win.flip()
    keypressed = event.waitKeys(timeStamped=False)
    checkclock.reset()
elif colour_order1 == 2:
    win.flip()
    paired_orange.draw()
    key_press.draw()
    win.flip()
    keypressed = event.waitKeys(timeStamped=False)
    checkclock.reset()
    
########################################################################################
########################################################################################








print('colour at start of 1st pairded = = =', colour_order1)
########################################################################################
########################################################################################
########################################################################################
# Paired Grid Trials - First Block:
########################################################################################
########################################################################################
########################################################################################
# Initialize components for Routine "init_experiment"
init_experimentClock = core.Clock()
# set_colors()
# Colors used during the experiment.s
def set_colors():
    global sc_c # screen color
    global f_c # frame color
    global sq_c # square color
    # 1 = white
    # -0.06 = grey 80
    # -0.37 = grey 120
    # -1 = black
    sc_c = 1
    f_c = -0.06
    sq_c = -0.37
    t_c = -0.06

# set_sizes()
# Sizes used during the experiment
def set_sizes():
    global f_s # frame size (square) (frame surrounding the stimulus)
    global sq_s # square size (square where the stimulus is shown)
    global l_s # line size (the width of the line surrounding the stimulus)
    f_s = 540
    sq_s = 800
    l_s = 100

########################################################################################
# Set conditions
########################################################################################
# Define conditions:
pairedconditionsB1 = []

for i in range(25):
    # CLOSE experimental trials:
    pairedconditionsB1.append(1)
    pairedconditionsB1.append(2)
    pairedconditionsB1.append(3)
    pairedconditionsB1.append(4)
    pairedconditionsB1.append(5)
    pairedconditionsB1.append(6)
    pairedconditionsB1.append(7)
    pairedconditionsB1.append(8)

# Conditions for practice trials 
pairedconditionsB1xx = [91,92,93,94,91,92,93,94,91,92,93,94,91,92,93,94,91,92,93,94,91,92,93,94,91,92,93,94,91,92,93,94,91,92,93,94,91,92,93,94]
#np.random.shuffle(pairedconditionsB1xx) # Randomly shuffle paired grid practice trials

# Randomly shuffle all the experimental conditions:
np.random.shuffle(pairedconditionsB1)

########################################################################################
########################################################################################

########################################################################################
# Set main conditions and loop
########################################################################################

# Counter to keep track of things
counter = 0
thecount = 0
ycounter = 1
supercounter = 0
break_count = 0
nowbreak = 1
pcounter2 = 1

xcounter = 0

# Keep track of number of correct responses during practice trials:
practice_correct = []*50

# Determine when to end practice trials:
ycounter_pracend = 0

done = 1

# Begin main trial loop here:
for j in range(infin_run):
    
    
    ######################################################
    ######################################################
    if j is 4 or j is 8 or j is 12 or j is 16 or j is 20:
        if done == 1:
            display_time = True
            win.flip()
            if len(practice_correct) == 0:
                while display_time:
                    #win.flip()
                    zero_per.draw()
                    win.flip()
                    practice_correct = [] # Continue practice trials
                    if event.getKeys(keyList=["1"]):
                        ycounter_pracend = 2
                        done = 2
                        ycounter = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        ycounter = 1
                        break
            elif len(practice_correct) == 1:
                while display_time:
                    #win.flip()
                    two_five_per.draw()
                    win.flip()
                    practice_correct = [] # Continue practice trials
                    if event.getKeys(keyList=["1"]):
                        ycounter_pracend = 2
                        ycounter = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        ycounter = 1
                        break
            elif len(practice_correct) == 2:
                while display_time:
                    #win.flip()
                    five_zero_per.draw()
                    win.flip()
                    practice_correct = [] # Continue practice trials
                    if event.getKeys(keyList=["1"]):
                        ycounter_pracend = 2
                        ycounter = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        ycounter = 1
                        break
            elif len(practice_correct) == 3:
                while display_time:
                    #win.flip()
                    seven_five_per.draw()
                    win.flip()
                    practice_correct = [] # Continue practice trials
                    if event.getKeys(keyList=["1"]):
                        ycounter_pracend = 2
                        ycounter = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        ycounter = 1
                        break
            elif len(practice_correct) == 4: # Participants got 100% here so can move onto experimental trials
                while display_time:
                    #win.flip()
                    zero_one_one_per.draw()
                    win.flip()
                    if event.getKeys(keyList=["1"]):
                        ycounter_pracend = 2
                        ycounter = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        ycounter = 1
                        break
    ######################################################
    ######################################################
    
    
    if ycounter == 2:
        pcounter2 = 2
    
    if pcounter2 == 1:
        pairedconditionsx = pairedconditionsB1xx[j] # Select what condition is to be performed on practice trial
        colour = 2
    elif pcounter > 1:
        # Set the colour order for the first colour block:
        colour_order1 = colour_order[0]
        pairedconditionsx = pairedconditionsB1[xcounter] # CLOSE block with experimental and control block
    
        
    # Set the conditions here:
    #############################################
    # The paired grid trials:
    #############################################
    
    if colour_order1 == 1: # IF THE QUESTION IS MORE BLUE:
        # E,E: (BB) Level 1 & 2:
        if pairedconditionsx == 1:
            colour = colour_order1
            p1 = .65
            p2 = .65
            
        # E,E: (OB) Level 1 & 2:
        elif pairedconditionsx == 2:
            colour = colour_order1
            p1=.35
            p2=.65
        
        # H,H: (bb) level 1 & 2:
        elif pairedconditionsx == 3:
            colour= colour_order1
            p1= hard_proportion
            p2= hard_proportion
        
        # H,H: (ob) level 1 & 2:
        elif pairedconditionsx == 4:
            colour= colour_order1
            p1= 1-hard_proportion
            p2= hard_proportion
        
        # H,E: (bB) level 1 & 2:
        if pairedconditionsx == 5:
            colour = colour_order1
            p1 = hard_proportion
            p2 = .65
            
        # H,E: (oB) level 1 & 2:
        elif pairedconditionsx == 6:
            colour = colour_order1
            p1= 1-hard_proportion
            p2=.65
        
        # E,H: (Bo) level 1 & 2:
        elif pairedconditionsx == 7:
            colour= colour_order1
            p1=.65
            p2= 1-hard_proportion
        
        # E,H: (Bb) level 1 & 2:
        elif pairedconditionsx == 8:
            colour= colour_order1
            p1=.65
            p2= hard_proportion
            
    if colour_order1 == 2: # IF THE QUESTION IS MORE ORANGE:
        # E,E: (BO) level 1 & 2:
        if pairedconditionsx == 1:
            colour = colour_order1
            p1 = .35
            p2 = .65
            
        # E,E: (OO) level 1 & 2:
        elif pairedconditionsx == 2:
            colour = colour_order1
            p1=.65
            p2=.65
        
        # H,H: (bo) level 1 & 2:
        elif pairedconditionsx == 3:
            colour= colour_order1
            p1= 1-hard_proportion
            p2= hard_proportion
        
        # H,H: (oo) level 1 & 2:
        elif pairedconditionsx == 4:
            colour= colour_order1
            p1= hard_proportion
            p2= hard_proportion
        
        # H,E: (bO) level 1 & 2 :
        if pairedconditionsx == 5:
            colour = colour_order1
            p1 = 1-hard_proportion
            p2 = .65
            
        # H,E: (oO) level 1 & 2:
        elif pairedconditionsx == 6:
            colour = colour_order1
            p1= hard_proportion
            p2=.65
        
        # E,H: (Ob) level 1 & 2:
        elif pairedconditionsx == 7:
            colour= colour_order1
            p1=.65
            p2= 1-hard_proportion
        
        # E,H: (Oo) level 1 & 2:
        elif pairedconditionsx == 8:
            colour= colour_order1
            p1=.65
            p2= hard_proportion
    
    
    #############################################
    #############################################
    
    #############################################
    # Practice trial conditions:
    #############################################
    # EE:
    if pairedconditionsx == 91:
        p1 = .35 # orange
        p2 = .65 # orange
        leftside  = [-8.5,0]
        rightside = [8.5,0]
    elif pairedconditionsx == 92:
        p1 = .65 # orange
        p2 = .35 # orange
        leftside  = [-8.5,0]
        rightside = [8.5,0]
    elif pairedconditionsx == 93:
        p1=.35 # orange
        p2=.35 # orange
        leftside  = [-8.5,0]
        rightside = [8.5,0]
    elif pairedconditionsx == 94:
        p1=.65 # orange
        p2=.65 # orange
        leftside  = [-8.5,0]
        rightside = [8.5,0]
    #############################################
    #############################################
    
    
    # Collecting the condition we are on:
    if  pcounter2 > 1:
        # Append the condition and the probabilities given:
        if colour_order1 == 1: # If colour is Blue
            if pairedconditionsx == 1:
                conused2.append('B1,B1')
                difflevel2.append('Exp - Easy 1 & Easy 1')
            elif pairedconditionsx == 2:
                conused2.append('O1,B1')
                difflevel2.append('Exp - Easy 1 & Easy 1')
            elif pairedconditionsx == 3:
                conused2.append('b1,b1')
                difflevel2.append('Exp - Hard 1 & Hard 1')
            elif pairedconditionsx == 4:
                conused2.append('o1,b1')
                difflevel2.append('Exp - Hard 1 & Hard 1')
            elif pairedconditionsx == 5:
                conused2.append('b1,B1')
                difflevel2.append('Con - Hard 1 & Easy 1')
            elif pairedconditionsx == 6:
                conused2.append('o1,B1')
                difflevel2.append('Con - Hard 1 & Easy 1')
            elif pairedconditionsx == 7:
                conused2.append('B1,o1')
                difflevel2.append('Con - Easy 1 & Hard 1')
            elif pairedconditionsx == 8:
                conused2.append('B1,b1')
                difflevel2.append('Con - Easy 1 & Hard 1')
                
        elif colour_order1 == 2: # If colour is Orange
            if pairedconditionsx == 1:
                conused2.append('B1,O1')
                difflevel2.append('Exp - Easy 1 & Easy 1')
            elif pairedconditionsx == 2:
                conused2.append('O1,O1')
                difflevel2.append('Exp - Easy 1 & Easy 1')
            elif pairedconditionsx == 3:
                conused2.append('b1,o1')
                difflevel2.append('Exp - Hard 1 & Hard 1')
            elif pairedconditionsx == 4:
                conused2.append('o1,o1')
                difflevel2.append('Exp - Hard 1 & Hard 1')
            elif pairedconditionsx == 5:
                conused2.append('O1,b1')
                difflevel2.append('Con - Easy 1 & Hard 1')
            elif pairedconditionsx == 6:
                conused2.append('O1,o1')
                difflevel2.append('Con - Easy 1 & Hard 1')
            elif pairedconditionsx == 7:
                conused2.append('b1,O1')
                difflevel2.append('Con - Hard 1 & Easy 1')
            elif pairedconditionsx == 8:
                conused2.append('o1,O1')
                difflevel2.append('Con - Hard 1 & Easy 1')
                
                
                
                
    #############################################
    #############################################
    # Set the distances for the stimuli
    #############################################
    #############################################
    if 1 <= pairedconditionsx <= 16:
        leftside  = [-8.5,0]
        rightside = [8.5,0]
    #############################################
    #############################################
    
    
    # Set the position of left stimulus
    def set_positions():
        global fl_p # Where should the flash be drawn
        fl_p = leftside
            
    # Set the position of right stimulus
    def set_positions2():
        global fl_p2 # Where should the flash be drawn
        fl_p2 = rightside
        
    # flash stimulus functions
    # flash initialization
    def flash_init(win, position=[0,0], position2=[0,0], square_size=10, columns=20, rows=20, percent_color1=p1, percent_color2=p2): # Colour 1 being manipulated
        global flash # The flash stimulus (an array of flashing squares)
        global flash2
        
        if colour == 1:
            color_set = [color2, color1]   # Blue
            color_set2 = [color2, color1]  # Blue
        elif colour == 2:
            color_set = [color1, color2]   # Orange
            color_set2 = [color1, color2]  # Orange
        cell_number = columns * rows
    
        num_color1 = int(np.floor(float(cell_number)*percent_color1)) # First colour
        num_color2 = int(np.floor(float(cell_number)*(1-percent_color1))) # Second colour
    
        num_color3 = int(np.floor(float(cell_number)*percent_color2)) # First colour
        num_color4 = int(np.floor(float(cell_number)*(1-percent_color2))) # Second colour
        
        # fill an array with colors. Each color should appear approximatively the same number of times.
        f_colors = []
        for i in range(num_color1):
            f_colors.append(color_set[0])
        for i in range(num_color2):
            f_colors.append(color_set[1])
        numpy.random.shuffle(color_set)
        i = cell_number - len(f_colors)
        while i > 0:
            f_colors.append(color_set[i])
            i -= 1
        
        f_colors2 = []
        for i in range(num_color3):
            f_colors2.append(color_set2[0])
        for i in range(num_color4):
            f_colors2.append(color_set2[1])
        numpy.random.shuffle(color_set2)
        i = cell_number - len(f_colors2)
        while i > 0:
            f_colors2.append(color_set2[i])
            i -= 1
        
        # randomize color order.
        shuffle(f_colors)
        shuffle(f_colors2)
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys.append((x_left + c * square_size, y_top + l * square_size))
        
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys2 = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys2.append((x_left + c * square_size, y_top + l * square_size))
        
        # MAIN FUNCTION TO CREATE FIRST GRID
        flash = visual.ElementArrayStim(win=win,
                            fieldPos=position,
                            fieldShape='sqr',
                            nElements=cell_number,
                            sizes=square_size,
                            xys=xys,
                            colors=f_colors,
                            elementTex=None,
                            elementMask=None,
                            name='flash',
                            autoLog=False)
                            
        # MAIN FUNCTION TO CREATE SECOND GRID
        flash2 = visual.ElementArrayStim(win=win,
                        fieldPos=position2,
                        fieldShape='sqr',
                        nElements=cell_number,
                        sizes=square_size,
                        xys=xys2,
                        colors=f_colors2,
                        elementTex=None,
                        elementMask=None,
                        name='flash',
                        autoLog=False)
                            
                            
    
    # flash stimulus change
    def flash_change():
        global flash
        shuffle(flash.colors)
        flash.setColors(flash.colors)
    
    def flash2_change():
        global flash2
        shuffle(flash2.colors)
        flash2.setColors(flash2.colors)
    
    # Time variables used during the experiment
    def set_timing():
        global f_t 
        f_t = 5 # The duration (in frame) of a flash image presentation
    
    # data_init
    set_colors()
    set_sizes()
    set_positions()
    set_positions2()
    set_timing()
    
    #############################
    # MAIN FUNCTION HERE
    flash_init(win, fl_p, fl_p2, square_size=0.3, columns=20, rows=20) # set the parameters here for the function!!
    #############################
    
    # Initialize components for Routine "show_flash"
    show_flashClock = core.Clock()
    frame_fl = visual.ImageStim(win=win, name='frame_fl',
        image=None, mask=None,
        ori=0, pos=fl_p, size=f_s,
        color=f_c, colorSpace='rgb', opacity=1,
        flipHoriz=False, flipVert=False,
        texRes=128, interpolate=True, depth=0.0)
    
    # Create some handy timers
    globalClock = core.Clock()  # to track the time since experiment started
    routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine 
    
    #------Prepare to start Routine "init_experiment"-------
    t = 0
    frameN = -1
    
    #------Prepare to start Routine "show_flash"-------
    t = 0
    show_flashClock.reset()  # clock 
    frameN = -1
    # update component parameters for each repeat
    # flash begin routine
    f_change = 0
    
    # keep track of which components have finished
    show_flashComponents = []
    show_flashComponents.append(frame_fl)
    for thisComponent in show_flashComponents:
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    ########################################################################################
    ########################################################################################
    
    
    ########################################################################################
    # MAIN EXPERIMENT
    ########################################################################################
    
    if ycounter_pracend == 2:
        win.flip()
        endspractice2.draw()
        endspractice20.draw()
        win.flip()
        keypressed = event.waitKeys(timeStamped=False)
        
        
    # If P's are doing experimental trials then have introduction text at the start of each block:
    if ycounter_pracend == 2:
        if colour_order1 == 1:
            win.flip()
            blockfourthtext.draw()
            blockonetext150.draw()
            win.flip()
            keypressed = event.waitKeys(timeStamped=False)
            checkclock.reset()
        elif colour_order1 == 2:
            win.flip()
            blocktwotext.draw()
            blockonetext150.draw()
            win.flip()
            keypressed = event.waitKeys(timeStamped=False)
            checkclock.reset()
         
        # Update th ycounter_pracend counter so that end practice trial tet does not show up again
        ycounter_pracend = 10
            
            
            
    #---Start Routine "show_flash"-------
    continueRoutine = True
    while continueRoutine:
            
        # Hides mouse
        mouse = event.Mouse(visible=0)
        
        # get current time
        t = show_flashClock.getTime()
        #print("t =", t)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        
        # *frame_fl* updates
        if t >= 0.0 and frame_fl.status == NOT_STARTED:
            # keep track of start time/frame for later
            frame_fl.tStart = t  # underestimates by a little under one frame
            frame_fl.frameNStart = frameN  # exact frame index
            frame_fl.draw()
        # flash each frame
        if frameN >= f_change:
            flash_change()
            flash2_change()
            f_change += f_t
            
        flash.draw()  # First stimulus is drawn here
        flash2.draw() # Second stimulus is drawn here
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineTimer.reset()  # if we abort early the non-slip timer needs reset
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in show_flashComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        
        
        if ycounter < practicetrials_pass:
            # PRACTICE TRIALS:
            if event.getKeys(keyList=["6"]):
                win.close()
                core.quit()
            if event.getKeys(keyList=["z"]):
                if colour_order1 == 1: # BLUE
                    if pairedconditionsx is 93:
                        win.flip()
                        correct_res.draw()
                        win.flip()
                        core.wait(2.0)
                        # Keep track of all the correct responses:
                        practice_correct.append('1')
                    else:
                        win.flip()
                        incorrect_res.draw()
                        win.flip()
                        core.wait(2.0)
                elif colour_order1 == 2: # ORANGE
                    if pairedconditionsx is 94:
                        win.flip()
                        correct_res.draw()
                        win.flip()
                        core.wait(2.0)
                        # Keep track of all the correct responses:
                        practice_correct.append('1')
                    else:
                        win.flip()
                        incorrect_res.draw()
                        win.flip()
                        core.wait(2.0)
                event.clearEvents(eventType='keyboard')
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock.reset()
                event.clearEvents(eventType='keyboard')
                break
            elif event.getKeys(keyList=["m"]):
                if colour_order1 == 1: # BLUE
                    if pairedconditionsx is 91 or pairedconditionsx is 92 or pairedconditionsx is 94:
                        win.flip()
                        correct_res.draw()
                        win.flip()
                        core.wait(2.0)
                        # Keep track of all the correct responses:
                        practice_correct.append('1')
                    else:
                        win.flip()
                        incorrect_res.draw()
                        win.flip()
                    core.wait(2.0)
                elif colour_order1 == 2: # ORANGE
                    if pairedconditionsx is 91 or pairedconditionsx is 92 or pairedconditionsx is 93:
                        win.flip()
                        correct_res.draw()
                        win.flip()
                        core.wait(2.0)
                        # Keep track of all the correct responses:
                        practice_correct.append('1')
                    else:
                        win.flip()
                        incorrect_res.draw()
                        win.flip()
                        core.wait(2.0)
                event.clearEvents(eventType='keyboard')
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock.reset()
                event.clearEvents(eventType='keyboard')
                break
        # EXPERIMENTAL TRIALS:
        elif ycounter >= practicetrials_pass:
            if event.getKeys(keyList=["escape"]):
                win.flip()
                breaktext.draw()
                win.flip()
                keypressed = event.waitKeys(timeStamped=False)
                checkclock.reset()
            if event.getKeys(keyList=["6"]):
                win.close()
                core.quit()
            # RESPONSE 1: (Left Side)
            if event.getKeys(keyList=["z"]): # MORE OF A COLOUR
                
                # Update the ycounter
                ycounter = ycounter+1
                
                # Update the xcounter:
                xcounter = xcounter+1
                
                # Collect correct/incorrect responses
                if colour_order1 == 1: # BLUE    
                    if pairedconditionsx is 1 or pairedconditionsx is 3 or pairedconditionsx is 5 or pairedconditionsx is 8:
                        correctresponse2.append('1')
                    else:
                        correctresponse2.append('0')
                elif colour_order1 == 2: # ORANGE
                    if pairedconditionsx is 2 or pairedconditionsx is 4 or pairedconditionsx is 6 or pairedconditionsx is 8:
                        correctresponse2.append('1')
                    else:
                        correctresponse2.append('0')
                
                # Keep track of keys pressed
                keyspressed2.append('left')
                
                # Update the counters:
                counter = counter+1
                
                # Keep track of trial number to be saved 
                trialNo2.append(counter)
                
                time2 = checkclock.getTime()
                RT2.append(time2)
                
                # DRAW FIXATION CROSS AFTER EACH TRIAL
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock.reset()
                event.clearEvents(eventType='keyboard')
                
                # END THE EXPERIMENT HERE
                if counter == pairedtrials:
                    win.flip() # Clears the window
                    endtext.draw() # Draw ending message here
                    win.flip() # Clears the window
                    core.wait(5.0)
                break
                
             # RESPONSE 2: (Right Side)
            if event.getKeys(keyList=["m"]): # LESS OF A COLOUR
                
                # Update the ycounter
                ycounter = ycounter+1
                
                # Update the ycounter:
                xcounter = xcounter+1
                
                # Collect correct/incorrect responses
                if colour_order1 == 1: # If question is more     
                    if pairedconditionsx is 2 or pairedconditionsx is 4 or pairedconditionsx is 6 or pairedconditionsx is 7:
                        correctresponse2.append('1')
                    else:
                        correctresponse2.append('0')
                elif colour_order1 == 2:
                    if pairedconditionsx is 1 or pairedconditionsx is 3 or pairedconditionsx is 5 or pairedconditionsx is 7:
                        correctresponse2.append('1')
                    else:
                        correctresponse2.append('0')
                    
                # Keep track of keys pressed
                keyspressed2.append('right')
                
                # Update the counter
                counter = counter+1
                
                # Keep track of trial number to be saved 
                trialNo2.append(counter)
                
                time2 = checkclock.getTime()
                RT2.append(time2)
                
                # DRAW FIXATION CROSS AFTER EACH TRIAL
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock.reset()
                event.clearEvents(eventType='keyboard')
                
                # END THE EXPERIMENT HERE
                if counter == pairedtrials:
                    win.flip() # Clears the window
                    endtext.draw() # Draw ending message here
                    win.flip() # Clears the window
                    core.wait(5.0)
                break
             
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
        else:  # this Routine was not non-slip safe so reset non-slip timer
            routineTimer.reset()
            
        # END THE EXPERIMENT HERE
        if counter == pairedtrials:
             break
             
    # END THE EXPERIMENT HERE
    if counter == pairedtrials:
         break
             
#-------Ending Routine "show_flash"-------
for thisComponent in show_flashComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
########################################################################################
########################################################################################





# Shuffle the experimental single trial conditions again:
np.random.shuffle(singleconditions_all)

# Determine what the target colour for this block is:
colour_order1 = colour_order[1]

########################################################################################
########################################################################################
########################################################################################
# Single Grid Trials - Second Block:
########################################################################################
########################################################################################
########################################################################################
# Initialize components for Routine "init_experiment"
init_experimentClock = core.Clock()
# set_colors()
# Colors used during the experiment.s
def set_colors():
    global sc_c # screen color
    global f_c # frame color
    global sq_c # square color
    # 1 = white
    # -0.06 = grey 80
    # -0.37 = grey 120
    # -1 = black
    sc_c = 1
    f_c = -0.06
    sq_c = -0.37
    t_c = -0.06

# set_sizes()
# Sizes used during the experiment
def set_sizes():
    global f_s # frame size (square) (frame surrounding the stimulus)
    global sq_s # square size (square where the stimulus is shown)
    global l_s # line size (the width of the line surrounding the stimulus)
    f_s = 540
    sq_s = 800
    l_s = 100
    
# Set the position of left stimulus
def set_positions01():
    global fl_p3 # Where should the flash be drawn
    fl_p3 = [0, 0]

########################################################################################
# Set main conditions and loop
########################################################################################

# Counter to keep track of things
counters2 = 0
thecounts2 = 0
counter01s2 = 0
thecount01s2 = 0
pcounters2 = 0  # practicetrials+1
pcounter2s2 = 1

# Keep track of number of correct responses during practice trials:
practice_correct = []*50

# REdefine the number of practice trials you need correct before you move on:
practicetrials_pass = 2

# Keep track of when to show practice trial text:
pcounter_practext = 1

done =1

for j in range(infin_run):
     
    ##########################################################
    # Determine if they passed or failed practice trials text:
    ##########################################################
     
    if j is 4 or j is 8 or j is 12 or j is 16 or j is 20:
        if done == 1:
            win.flip()
            display_time = True
            if len(practice_correct) == 0:
                while display_time:
                    #win.flip()
                    zero_per.draw()
                    win.flip()
                    practice_correct = [] # Continue practice trials
                    if event.getKeys(keyList=["1"]):
                        pcounters2 = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        pcounters2 = 1
                        break
            elif len(practice_correct) == 1:
                while display_time:
                    #win.flip()
                    two_five_per.draw()
                    win.flip()
                    practice_correct = [] # Continue practice trials
                    if event.getKeys(keyList=["1"]):
                        pcounters2 = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        pcounters2 = 1
                        break
            elif len(practice_correct) == 2:
                while display_time:
                    #win.flip()
                    five_zero_per.draw()
                    win.flip()
                    practice_correct = [] # Continue practice trials
                    if event.getKeys(keyList=["1"]):
                        pcounters2 = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        pcounters2 = 1
                        break
            elif len(practice_correct) == 3:
                while display_time:
                    #win.flip()
                    seven_five_per.draw()
                    win.flip()
                    practice_correct = [] # Continue practice trials
                    if event.getKeys(keyList=["1"]):
                        pcounters2 = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        pcounters2 = 1
                        break
            elif len(practice_correct) == 4: # Participants got 100% here so can move onto experimental trials
                while display_time:
                    #win.flip()
                    zero_one_one_per.draw()
                    win.flip()
                    if event.getKeys(keyList=["1"]):
                        pcounters2 = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        pcounters2 = 1
                        break
                    
    ##########################################################
    ##########################################################
     
     
     
    if pcounters2 < practicetrials_pass:
        singleconditionsx = singlegridpractice[j]
        if singleconditionsx >= 3:
            colour_order1 == 2 # ORANGE
        else:
            colour_order1 == 1 # BLUE
    else:
        # Select what condition is to be performed on experimental trials:
        if colour_order1 == 1:
            singleconditionsx = singleconditions_all[counter01s2]
        elif colour_order1 == 2:
            singleconditionsx = singleconditions_all[counter01s2]
        
    
    if pcounters2 >= 2:
        # Append the condition we're on:
        if singleconditionsx == 1:
            conused3.append('b,o')
            difflevel3.append('Exp - Hard 1')
        elif singleconditionsx == 2:
            conused3.append('B,o')
            difflevel3.append('Con - Easy 1')
        elif singleconditionsx == 3:
            conused3.append('o,b')
            difflevel3.append('Exp - Hard 1')
        elif singleconditionsx == 4:
            conused3.append('O,b')
            difflevel3.append('Con - Easy 1')

     
     
     
    # Set the conditions here:
    # BLUE colours:
    if singleconditionsx == 1:
        p01 = hard_proportion #(48/52)
    elif singleconditionsx == 2:
        p01 = .65 #(65/35)
        
    # Orange colours:
    elif singleconditionsx == 3:
        p01 = hard_proportion #(48/52)
    elif singleconditionsx == 4:
        p01 = .65 #(65/35)
        
     
    # flash stimulus functions
    # flash initialization
    def flash_init(win, position01=[0,0], square_size=10, columns=20, rows=20, percent_color01=p01): # Colour2 being manipulated whic is BLUE
        global flash01s2 # The flash stimulus (an array of flashing squares)
        
        if singleconditionsx <= 2:
            color_set01 = [color2, color1] # color2 being manipulated which is the BLUE
        elif singleconditionsx >= 3:
            color_set01 = [color1, color2] # colour1 is being manipulated which is the ORANGE
        cell_number = columns * rows
    
        num_color4 = int(np.floor(float(cell_number)*percent_color01)) # First colour
        num_color5 = int(np.floor(float(cell_number)*(1-percent_color01))) # Second colour
        
        # fill an array with colors. Each color should appear approximatively the same number of times.
        f_colors3s2 = []
        for i in range(num_color4):
            f_colors3s2.append(color_set01[0])
        for i in range(num_color5):
            f_colors3s2.append(color_set01[1])
        numpy.random.shuffle(color_set01)
        i = cell_number - len(f_colors3s2)
        while i > 0:
            f_colors3s2.append(color_set01[i])
            i -= 1
        
        # randomize color order.
        shuffle(f_colors3s2)
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys.append((x_left + c * square_size, y_top + l * square_size))
        
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys2 = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys2.append((x_left + c * square_size, y_top + l * square_size))
        
        # MAIN FUNCTION TO CREATE FIRST GRID
        flash01s2 = visual.ElementArrayStim(win=win,
                            fieldPos=position01,
                            fieldShape='sqr',
                            nElements=cell_number,
                            sizes=square_size,
                            xys=xys,
                            colors=f_colors3s2,
                            elementTex=None,
                            elementMask=None,
                            name='flash',
                            autoLog=False)
                            
                            
                            
    
    # flash stimulus change
    def flash_changes2():
        global flash01s2
        shuffle(flash01s2.colors)
        flash01s2.setColors(flash01s2.colors)
    
    # Time variables used during the experiment
    def set_timings2():
        global f_t 
        f_t = 5 # The duration (in frame) of a flash image presentation
    
    # data_init
    set_colors()
    set_sizes()
    set_positions01()
    set_timing()
    
    #############################
    # MAIN FUNCTION HERE
    flash_init(win, fl_p3, square_size=0.3, columns=20, rows=20) # set the parameters here for the function!!
    #############################
    
    # Initialize components for Routine "show_flash"
    show_flashClock01s2 = core.Clock()
    frame_fl = visual.ImageStim(win=win, name='frame_fl',
        image=None, mask=None,
        ori=0, pos=fl_p3, size=f_s,
        color=f_c, colorSpace='rgb', opacity=1,
        flipHoriz=False, flipVert=False,
        texRes=128, interpolate=True, depth=0.0)
    
    # Create some handy timers
    globalClock01s2 = core.Clock()  # to track the time since experiment started
    routineTimer01s2 = core.CountdownTimer()  # to track time remaining of each (non-slip) routine 
    
    #------Prepare to start Routine "init_experiment"-------
    t = 0
    frameN = -1
    
    #------Prepare to start Routine "show_flash"-------
    t = 0
    show_flashClock01s2.reset()  # clock 
    frameN = -1
    # update component parameters for each repeat
    # flash begin routine
    f_change = 0
    
    # keep track of which components have finished
    show_flashComponents01s2 = []
    show_flashComponents01s2.append(frame_fl)
    for thisComponent in show_flashComponents01:
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    ########################################################################################
    ########################################################################################
    
    
    ########################################################################################
    # MAIN EXPERIMENT
    ########################################################################################
    
    
    ####################################################
    # Put the practice trial and introduction text here:
    ####################################################
    # Practice trial text: 
    if pcounter_practext == 1:
        if colour_order1 == 1:
            win.flip()
            single_blue.draw()
            key_press.draw()
            win.flip()
            keypressed = event.waitKeys(timeStamped=False)
            checkclock01s2.reset()
        elif colour_order1 == 2:
            win.flip()
            single_orange.draw()
            key_press.draw()
            win.flip()
            keypressed = event.waitKeys(timeStamped=False)
            checkclock01s2.reset()
        pcounter_practext = 2
                   
    # Experimental trial text:
    if pcounters2 == 2:
        if colour_order1 == 1:
            win.flip()
            endspractice_b1.draw()
            endspractice_b2.draw()
            endspractice_bf.draw()
            win.flip()
        elif colour_order1 == 2:
            win.flip()
            endspractice_o1.draw()
            endspractice_o2.draw()
            endspractice_of.draw()
            win.flip()
        keypressed = event.waitKeys(timeStamped=False)
        checkclock01s2.reset()
        
    ####################################################
    ####################################################
    
    
    #---Start Routine "show_flash"-------
    continueRoutine = True
    while continueRoutine:    
        # Hides mouse
        mouse = event.Mouse(visible=0)
        
        # get current time
        t = show_flashClock01s2.getTime()
        #print("t =", t)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        
        # update/draw components on each frame
        #print(frameN)
        
        # *frame_fl* updates
        if t >= 0.0 and frame_fl.status == NOT_STARTED:
            # keep track of start time/frame for later
            frame_fl.tStart = t  # underestimates by a little under one frame
            frame_fl.frameNStart = frameN  # exact frame index
            frame_fl.draw()
        # flash each frame
        if frameN >= f_change:
            flash_changes2()
            f_change+= f_t
#        if colour_order1 == 1:
#            strialtextb.draw()
#        elif colour_order1 == 2:
#            #strialtexto.draw()
        flash01s2.draw()  # First stimulus is drawn here
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineTimer01s2.reset()  # if we abort early the non-slip timer needs reset
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in show_flashComponents01s2:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
         
        # PRACTICE TRIALS:
        if pcounters2 < practicetrials_pass:
            if event.getKeys(keyList=["6"]):
                win.close()
                core.quit()
            if event.getKeys(keyList=["z"]):
                if colour_order1 == 1: # BLUE
                    if singleconditionsx is 2 or singleconditionsx is 3:
                        win.flip()
                        correct_res.draw()
                        win.flip()
                        practice_correct.append('1') # Keep track of the number of correct practice trial responses here
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                    else:
                        win.flip()
                        incorrect_res.draw()
                        win.flip()
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                elif colour_order1 == 2: # ORANGE
                    if singleconditionsx is 3 or singleconditionsx is 4:
                        win.flip()
                        correct_res.draw()
                        win.flip()
                        practice_correct.append('1') # Keep track of the number of correct practice trial responses here
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                    else:
                        win.flip()
                        incorrect_res.draw()
                        win.flip()
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                event.clearEvents(eventType='keyboard')
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock01s2.reset()
                event.clearEvents(eventType='keyboard')
                break
            elif event.getKeys(keyList=["m"]):
                if colour_order1 == 1: # BLUE
                    if singleconditionsx is 3 or singleconditionsx is 4:
                        win.flip()
                        correct_res.draw()
                        win.flip()
                        practice_correct.append('1') # Keep track of the number of correct practice trial responses here
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                    else:
                        win.flip()
                        incorrect_res.draw()
                        win.flip()
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                elif colour_order1 == 2: # ORANGE
                    if singleconditionsx is 1 or singleconditionsx is 2:
                        win.flip()
                        correct_res.draw()
                        win.flip()
                        practice_correct.append('1') # Keep track of the number of correct practice trial responses here
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                    else:
                        win.flip()
                        incorrect_res.draw()
                        win.flip()
                        core.wait(1.5) # Keep the cross on screen for 2 seconds
                event.clearEvents(eventType='keyboard')
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock01s2.reset()
                event.clearEvents(eventType='keyboard')
                break
        # EXPERIMENTAL TRIALS:
        elif pcounters2 >= practicetrials_pass:
            #EXPERIMENTAL TRIALS: RESPONSE 1: (Left Side - BLUE)
            if event.getKeys(keyList=["escape"]):
                win.flip()
                breaktext.draw()
                win.flip()
                keypressed = event.waitKeys(timeStamped=False)
                checkclock01s2.reset()
            if event.getKeys(keyList=["6"]):
                win.close()
                core.quit()
            if event.getKeys(keyList=["z"]): # MORE key
            
                # Update practice trial counter
                pcounters2 = pcounters2+1
                
                # print the condition we did
                print("actual single trial done =", singleconditionsx)
                
                # Track response times
                time01s2 = checkclock01s2.getTime()
                RTs2.append(time01s2)
                
                if colour_order1 == 1:
                    if singleconditionsx <= 2:
                        correctresponses2.append('1')
                        print('response ===========  correct')
                    elif singleconditionsx >= 3:
                        correctresponses2.append('0')
                        print('response ===========  incorrect')
                elif colour_order1 == 2:
                    if singleconditionsx <= 2:
                        correctresponses2.append('0')
                        print('response ===========  incorrect')
                    elif singleconditionsx >= 3:
                        correctresponses2.append('1')
                        print('response ===========  correct')
                # Append which colour question was being asked:
                colourcolour2.append(colour_order1)
                
                # Keep track of keys pressed
                keyspresseds2.append('left')
                
                # Update the counter
                counter01s2 = counter01s2+1
                
                # Keep track of trial number to be saved 
                trialNos2.append(counter01s2)
                
                
                # DRAW FIXATION CROSS AFTER EACH TRIAL
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock01s2.reset()
                event.clearEvents(eventType='keyboard')
                
                # END THE EXPERIMENT HERE AND SAVE DATA
                if counter01s2 == singletrials:
                    win.flip() # Clears the window
                    endtext0122.draw() # Draw ending message here
                    endtext01229.draw()
                    win.flip() # Clears the window
                    keypressed = event.waitKeys(timeStamped=False)
                break      
                 
                 
             # RESPONSE 2: (Right Side - ORANGE)
            if event.getKeys(keyList=["m"]): # LESS key
                
                # Update practice trial counter
                pcounters2 = pcounters2+1
                
                # print the condition we did
                print("actual single trial done =", singleconditionsx)
                
                time01s2 = checkclock01s2.getTime()
                RTs2.append(time01s2)
                
                if colour_order1 == 1:
                    if singleconditionsx <= 2:
                        correctresponses2.append('0')
                        print('response ===========  incorrect')
                    elif singleconditionsx >= 3:
                        correctresponses2.append('1')
                        print('response ===========  correct')
                elif colour_order1 == 2:
                    if singleconditionsx <= 2:
                        correctresponses2.append('1')
                        print('response ===========  correct')
                    elif singleconditionsx >= 3:
                        correctresponses2.append('0')
                        print('response ===========  incorrect')
                # Append which colour question was being asked:
                colourcolour2.append(colour_order1)
                
                # Keep track of keys pressed
                keyspresseds2.append('right')
                
                # Update the counter
                counter01s2 = counter01s2+1
                
                # Keep track of trial number to be saved 
                trialNos2.append(counter01s2)
                
                
                # DRAW FIXATION CROSS AFTER EACH TRIAL
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock01s2.reset()
                event.clearEvents(eventType='keyboard')
                
                # END THE EXPERIMENT HERE AND SAVE DATA
                if counter01s2 == singletrials:
                    win.flip() # Clears the window
                    endtext0122.draw() # Draw ending message here
                    endtext01229.draw()
                    win.flip() # Clears the window
                    keypressed = event.waitKeys(timeStamped=False)
                break # End the expriment
             
             
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
        else:  # this Routine was not non-slip safe so reset non-slip timer
            routineTimer.reset()
             
        # END THE EXPERIMENT HERE:
        if counter01s2 == singletrials:
            break
            
    # END THE EXPERIMENT HERE:
    if counter01s2 == singletrials:
        break
            
#-------Ending Routine "show_flash"-------
for thisComponent in show_flashComponents01s2:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
########################################################################################
########################################################################################





####################################################
# More paired grid trial introduction practice text:
####################################################
#win.flip()
#practicetext1q.draw()
#practicetext1qq.draw()
#win.flip()
#keypressed = event.waitKeys(timeStamped=False)
####################################################
####################################################
if colour_order1 == 1:
    win.flip()
    paired_blue.draw()
    key_press.draw()
    win.flip()
    keypressed = event.waitKeys(timeStamped=False)
    #checkclock.reset()
elif colour_order1 == 2:
    win.flip()
    paired_orange.draw()
    key_press.draw()
    win.flip()
    keypressed = event.waitKeys(timeStamped=False)
    #checkclock.reset()






########################################################################################
########################################################################################
########################################################################################
# Paired Grid Trials - Second Block
########################################################################################
########################################################################################
########################################################################################
# Initialize components for Routine "init_experiment"
init_experimentClock = core.Clock()
# set_colors()
# Colors used during the experiment.s
def set_colors():
    global sc_c # screen color
    global f_c # frame color
    global sq_c # square color
    # 1 = white
    # -0.06 = grey 80
    # -0.37 = grey 120
    # -1 = black
    sc_c = 1
    f_c = -0.06
    sq_c = -0.37
    t_c = -0.06

# set_sizes()
# Sizes used during the experiment
def set_sizes():
    global f_s # frame size (square) (frame surrounding the stimulus)
    global sq_s # square size (square where the stimulus is shown)
    global l_s # line size (the width of the line surrounding the stimulus)
    f_s = 540
    sq_s = 800
    l_s = 100

########################################################################################
# Set conditions
########################################################################################
# Pairded conditions list
pairedconditionsB1 = [] # A1 close

# Merge everything into a conditions list:
for i in range(25):
    # CLOSE experimental trials:
    pairedconditionsB1.append(1)
    pairedconditionsB1.append(2)
    pairedconditionsB1.append(3)
    pairedconditionsB1.append(4)
    pairedconditionsB1.append(5)
    pairedconditionsB1.append(6)
    pairedconditionsB1.append(7)
    pairedconditionsB1.append(8)


# Conditions for practice trials 
pairedconditionsB1xx = [91,92,93,94,91,92,93,94,91,92,93,94,91,92,93,94,91,92,93,94,91,92,93,94,91,92,93,94,91,92,93,94,91,92,93,94,91,92,93,94]
#np.random.shuffle(pairedconditionsB1xx) # Randomly shuffle paired grid practice trials

# Randomly shuffle all the conditions
np.random.shuffle(pairedconditionsB1)
########################################################################################
########################################################################################

########################################################################################
# Set main conditions and loop
########################################################################################
# Set the colour order for the first colour block:
#colour_order1 = colour_order[1]

# Counter to keep track of things
pcounter2 = 1
counter = 0
thecount = 0
ycounter = 1
supercounter = 0
break_count = 0
pcounter2 = practicetrials
    
    
xcounter = 0
    
    
# keep track of number of correct responses during practice trials:
practice_correct = []*50

# Determine when to move on:
practicetrials_pass = 1


done = 1

for j in range(infin_run): # Should be 160 to make 320 paired grid trials in total
     
     
    #######################################################
    #######################################################
     if j is 4 or j is 8 or j is 12 or j is 16 or j is 20:
        if done == 1:
            win.flip()
            display_time = True
            if len(practice_correct) == 0:
                while display_time:
                    #win.flip()
                    zero_per.draw()
                    win.flip()
                    practice_correct = [] # Continue practice trials
                    if event.getKeys(keyList=["1"]):
                        ycounter_pracend = 2
                        ycounter = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        ycounter = 1
                        break
            elif len(practice_correct) == 1:
                while display_time:
                    #win.flip()
                    two_five_per.draw()
                    win.flip()
                    practice_correct = [] # Continue practice trials
                    if event.getKeys(keyList=["1"]):
                        ycounter_pracend = 2
                        ycounter = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        ycounter = 1
                        break
            elif len(practice_correct) == 2:
                while display_time:
                    #win.flip()
                    five_zero_per.draw()
                    win.flip()
                    practice_correct = [] # Continue practice trials
                    if event.getKeys(keyList=["1"]):
                        ycounter_pracend = 2
                        ycounter = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        ycounter = 1
                        break
            elif len(practice_correct) == 3:
                while display_time:
                    #win.flip()
                    seven_five_per.draw()
                    win.flip()
                    practice_correct = [] # Continue practice trials
                    if event.getKeys(keyList=["1"]):
                        ycounter_pracend = 2
                        ycounter = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        ycounter = 1
                        break
            elif len(practice_correct) == 4: # Participants got 100% here so can move onto experimental trials
                while display_time:
                    #win.flip()
                    zero_one_one_per.draw()
                    win.flip()
                    if event.getKeys(keyList=["1"]):
                        ycounter_pracend = 2
                        ycounter = 2
                        done = 2
                        break
                    elif event.getKeys(keyList=["0"]):
                        ycounter = 1
                        break
    #######################################################
    #######################################################
     
     
    ######################################################
     # Set the condition:
    ######################################################
     if ycounter == 1:
         pairedconditionsx = pairedconditionsB1xx[j]
         colour = 2
     elif ycounter >= 2:
         colour_order1 = colour_order[1]
         pairedconditionsx = pairedconditionsB1[xcounter] # CLOSE block with experimental and control block
    #######################################################
    #######################################################
    
    
    # Collect what condition we are on:
     if  ycounter > 1:
        # Append the condition and the probabilities given
        if colour_order1 == 1: # If colour is Blue
            if pairedconditionsx == 1:
                conused4.append('B1,B1')
                difflevel4.append('Exp - Easy 1 & Easy 1')
            elif pairedconditionsx == 2:
                conused4.append('O1,B1')
                difflevel4.append('Exp - Easy 1 & Easy 1')
            elif pairedconditionsx == 3:
                conused4.append('b1,b1')
                difflevel4.append('Exp - Hard 1 & Hard 1')
            elif pairedconditionsx == 4:
                conused4.append('o1,b1')
                difflevel4.append('Exp - Hard 1 & Hard 1')
            elif pairedconditionsx == 5:
                conused4.append('b1,B1')
                difflevel4.append('Con - Hard 1 & Easy 1')
            elif pairedconditionsx == 6:
                conused4.append('o1,B1')
                difflevel4.append('Con - Hard 1 & Easy 1')
            elif pairedconditionsx == 7:
                conused4.append('B1,o1')
                difflevel4.append('Con - Easy 1 & Hard 1')
            elif pairedconditionsx == 8:
                conused4.append('B1,b1')
                difflevel4.append('Con - Easy 1 & Hard 1')
                
        elif colour_order1 == 2: # If colour is Orange
            if pairedconditionsx == 1:
                conused4.append('B1,O1')
                difflevel4.append('Exp - Easy 1 & Easy 1')
            elif pairedconditionsx == 2:
                conused4.append('O1,O1')
                difflevel4.append('Exp - Easy 1 & Easy 1')
            elif pairedconditionsx == 3:
                conused4.append('b1,o1')
                difflevel4.append('Exp - Hard 1 & Hard 1')
            elif pairedconditionsx == 4:
                conused4.append('o1,o1')
                difflevel4.append('Exp - Hard 1 & Hard 1')
            elif pairedconditionsx == 5:
                conused4.append('O1,b1')
                difflevel4.append('Con - Easy 1 & Hard 1')
            elif pairedconditionsx == 6:
                conused4.append('O1,o1')
                difflevel4.append('Con - Easy 1 & Hard 1')
            elif pairedconditionsx == 7:
                conused4.append('b1,O1')
                difflevel4.append('Con - Hard 1 & Easy 1')
            elif pairedconditionsx == 8:
                conused4.append('o1,O1')
                difflevel4.append('Con - Hard 1 & Easy 1')
        
    # Set the conditions here:
    #############################################
    # The paired grid trials:
    #############################################
     if colour_order1 == 1: # IF THE QUESTION IS MORE BLUE:
        # E,E: (BB) Level 1 & 2:
        if pairedconditionsx == 1:
            colour = colour_order1
            p1 = .65
            p2 = .65
            
        # E,E: (OB) Level 1 & 2:
        elif pairedconditionsx == 2:
            colour = colour_order1
            p1=.35
            p2=.65
        
        # H,H: (bb) level 1 & 2:
        elif pairedconditionsx == 3:
            colour= colour_order1
            p1= hard_proportion
            p2= hard_proportion
        
        # H,H: (ob) level 1 & 2:
        elif pairedconditionsx == 4:
            colour= colour_order1
            p1= 1-hard_proportion
            p2= hard_proportion
        
        # H,E: (bB) level 1 & 2:
        if pairedconditionsx == 5:
            colour = colour_order1
            p1 = hard_proportion
            p2 = .65
            
        # H,E: (oB) level 1 & 2:
        elif pairedconditionsx == 6:
            colour = colour_order1
            p1= 1-hard_proportion
            p2=.65
        
        # E,H: (Bo) level 1 & 2:
        elif pairedconditionsx == 7:
            colour= colour_order1
            p1=.65
            p2= 1-hard_proportion
        
        # E,H: (Bb) level 1 & 2:
        elif pairedconditionsx == 8:
            colour= colour_order1
            p1=.65
            p2= hard_proportion
            
     if colour_order1 == 2: # IF THE QUESTION IS MORE ORANGE:
        # E,E: (BO) level 1 & 2:
        if pairedconditionsx == 1:
            colour = colour_order1
            p1 = .35
            p2 = .65
            
        # E,E: (OO) level 1 & 2:
        elif pairedconditionsx == 2:
            colour = colour_order1
            p1=.65
            p2=.65
        
        # H,H: (bo) level 1 & 2:
        elif pairedconditionsx == 3:
            colour= colour_order1
            p1= 1-hard_proportion
            p2= hard_proportion
        
        # H,H: (oo) level 1 & 2:
        elif pairedconditionsx == 4:
            colour= colour_order1
            p1= hard_proportion
            p2= hard_proportion
        
        # H,E: (bO) level 1 & 2 :
        if pairedconditionsx == 5:
            colour = colour_order1
            p1 = 1-hard_proportion
            p2 = .65
            
        # H,E: (oO) level 1 & 2:
        elif pairedconditionsx == 6:
            colour = colour_order1
            p1= hard_proportion
            p2=.65
        
        # E,H: (Ob) level 1 & 2:
        elif pairedconditionsx == 7:
            colour= colour_order1
            p1=.65
            p2= 1-hard_proportion
        
        # E,H: (Oo) level 1 & 2:
        elif pairedconditionsx == 8:
            colour= colour_order1
            p1=.65
            p2= hard_proportion
        
    #############################################
    #############################################
    
    
    #############################################
    # Practice trial conditions:
    #############################################
    # EE:
     if pairedconditionsx == 91:
        p1 = .35 # orange
        p2 = .65 # orange
        leftside  = [-8.5,0]
        rightside = [8.5,0]
     elif pairedconditionsx == 92:
        p1 = .65 # orange
        p2 = .35 # orange
        leftside  = [-8.5,0]
        rightside = [8.5,0]
     elif pairedconditionsx == 93:
        p1=.35 # orange
        p2=.35 # orange
        leftside  = [-8.5,0]
        rightside = [8.5,0]
     elif pairedconditionsx == 94:
        p1=.65 # orange
        p2=.65 # orange
        leftside  = [-8.5,0]
        rightside = [8.5,0]
    #############################################
    #############################################
    
    
    
    
    #############################################
    #############################################
    # Set the distances for the stimuli
    #############################################
    #############################################
     if 1 <= pairedconditionsx <= 16:
        leftside  = [-8.5,0]
        rightside = [8.5,0]
    #############################################
    #############################################
    
    
    # Set the position of left stimulus
     def set_positions():
        global fl_p # Where should the flash be drawn
        fl_p = leftside
            
    # Set the position of right stimulus
     def set_positions2():
        global fl_p2 # Where should the flash be drawn
        fl_p2 = rightside
        
    # flash stimulus functions
    # flash initialization
     def flash_init(win, position=[0,0], position2=[0,0], square_size=10, columns=20, rows=20, percent_color1=p1, percent_color2=p2): # Colour 1 being manipulated
        global flash # The flash stimulus (an array of flashing squares)
        global flash2
        
        if colour == 1:
            color_set = [color2, color1]   # Blue
            color_set2 = [color2, color1]  # Blue
        elif colour == 2:
            color_set = [color1, color2]   # Orange
            color_set2 = [color1, color2]  # Orange
        cell_number = columns * rows
    
        num_color1 = int(np.floor(float(cell_number)*percent_color1)) # First colour
        num_color2 = int(np.floor(float(cell_number)*(1-percent_color1))) # Second colour
    
        num_color3 = int(np.floor(float(cell_number)*percent_color2)) # First colour
        num_color4 = int(np.floor(float(cell_number)*(1-percent_color2))) # Second colour
        
        # fill an array with colors. Each color should appear approximatively the same number of times.
        f_colors = []
        for i in range(num_color1):
            f_colors.append(color_set[0])
        for i in range(num_color2):
            f_colors.append(color_set[1])
        numpy.random.shuffle(color_set)
        i = cell_number - len(f_colors)
        while i > 0:
            f_colors.append(color_set[i])
            i -= 1
        
        f_colors2 = []
        for i in range(num_color3):
            f_colors2.append(color_set2[0])
        for i in range(num_color4):
            f_colors2.append(color_set2[1])
        numpy.random.shuffle(color_set2)
        i = cell_number - len(f_colors2)
        while i > 0:
            f_colors2.append(color_set2[i])
            i -= 1
        
        # randomize color order.
        shuffle(f_colors)
        shuffle(f_colors2)
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys.append((x_left + c * square_size, y_top + l * square_size))
        
        
        # fill an array with coordinate for each color square. First square should be at the upper left
        # and next should follow from left to right and up to down.
        xys2 = []
        x_left = (1 - columns) * square_size / 2
        y_top = (1 - rows) * square_size / 2
        for l in range(rows):
            for c in range(columns):
                xys2.append((x_left + c * square_size, y_top + l * square_size))
        
        # MAIN FUNCTION TO CREATE FIRST GRID
        flash = visual.ElementArrayStim(win=win,
                            fieldPos=position,
                            fieldShape='sqr',
                            nElements=cell_number,
                            sizes=square_size,
                            xys=xys,
                            colors=f_colors,
                            elementTex=None,
                            elementMask=None,
                            name='flash',
                            autoLog=False)
                            
        # MAIN FUNCTION TO CREATE SECOND GRID
        flash2 = visual.ElementArrayStim(win=win,
                        fieldPos=position2,
                        fieldShape='sqr',
                        nElements=cell_number,
                        sizes=square_size,
                        xys=xys2,
                        colors=f_colors2,
                        elementTex=None,
                        elementMask=None,
                        name='flash',
                        autoLog=False)
                            
                            
    
    # flash stimulus change
     def flash_change():
        global flash
        shuffle(flash.colors)
        flash.setColors(flash.colors)
    
     def flash2_change():
        global flash2
        shuffle(flash2.colors)
        flash2.setColors(flash2.colors)
    
    # Time variables used during the experiment
     def set_timing():
        global f_t 
        f_t = 5 # The duration (in frame) of a flash image presentation
    
    # data_init
     set_colors()
     set_sizes()
     set_positions()
     set_positions2()
     set_timing()
    
    #############################
    # MAIN FUNCTION HERE
     flash_init(win, fl_p, fl_p2, square_size=0.3, columns=20, rows=20) # set the parameters here for the function!!
    #############################
    
    # Initialize components for Routine "show_flash"
     show_flashClock = core.Clock()
     frame_fl = visual.ImageStim(win=win, name='frame_fl',
        image=None, mask=None,
        ori=0, pos=fl_p, size=f_s,
        color=f_c, colorSpace='rgb', opacity=1,
        flipHoriz=False, flipVert=False,
        texRes=128, interpolate=True, depth=0.0)
    
    # Create some handy timers
     globalClock = core.Clock()  # to track the time since experiment started
     routineTimer = core.CountdownTimer()  # to track time remaining of each (non-slip) routine 
    
#    #------Prepare to start Routine "init_experiment"-------
#     t = 0
#     frameN = -1
    
    #------Prepare to start Routine "show_flash"-------
     t = 0
     show_flashClock.reset()  # clock 
     frameN = -1
    # update component parameters for each repeat
    # flash begin routine
     f_change = 0
    
    # keep track of which components have finished
     show_flashComponents = []
     show_flashComponents.append(frame_fl)
     for thisComponent in show_flashComponents:
        if hasattr(thisComponent, 'status'):
            thisComponent.status = NOT_STARTED
    ########################################################################################
    ########################################################################################
    
    
    ########################################################################################
    # MAIN EXPERIMENT
    ########################################################################################
    
     if ycounter == 2:
        win.flip()
        endspractice2.draw()
        endspractice20.draw()
        win.flip()
        pcounter_practext = 2
        keypressed = event.waitKeys(timeStamped=False)
        
    # If P's are doing experimental trials then have introduction text at the start of each block:
     if ycounter == 2:
        if colour_order1 == 1:
            win.flip()
            blockfourthtext.draw()
            blockonetext150.draw()
            win.flip()
            keypressed = event.waitKeys(timeStamped=False)
            checkclock.reset()
        elif colour_order1 == 2:
            win.flip()
            blocktwotext.draw()
            blockonetext150.draw()
            win.flip()
            keypressed = event.waitKeys(timeStamped=False)
            checkclock.reset()
            
        # Update the ycounter so that you do not repeat stuff:
        ycounter = 10
            
            
            

            
            
            
            
    #---Start Routine "show_flash"-------
     continueRoutine = True
     while continueRoutine:
            
        # Hides mouse
        mouse = event.Mouse(visible=0)
        
        # get current time
        t = show_flashClock.getTime()
        #print("t =", t)
        frameN = frameN + 1  # number of completed frames (so 0 is the first frame)
        
        # *frame_fl* updates
        if t >= 0.0 and frame_fl.status == NOT_STARTED:
            # keep track of start time/frame for later
            frame_fl.tStart = t  # underestimates by a little under one frame
            frame_fl.frameNStart = frameN  # exact frame index
            frame_fl.draw()
        # flash each frame
        if frameN >= f_change:
            flash_change()
            flash2_change()
            f_change += f_t
        
            
        flash.draw()  # First stimulus is drawn here
        flash2.draw() # Second stimulus is drawn here
        
        # check if all components have finished
        if not continueRoutine:  # a component has requested a forced-end of Routine
            routineTimer.reset()  # if we abort early the non-slip timer needs reset
            break
        continueRoutine = False  # will revert to True if at least one component still running
        for thisComponent in show_flashComponents:
            if hasattr(thisComponent, "status") and thisComponent.status != FINISHED:
                continueRoutine = True
                break  # at least one component has not yet finished
        
        
        # PRACTICE TRIALS:
        if ycounter <= 1:
            if event.getKeys(keyList=["6"]):
                win.close()
                core.quit()
            if event.getKeys(keyList=["z"]):
                if colour_order1 == 1: # BLUE
                    if pairedconditionsx is 93:
                        win.flip()
                        correct_res.draw()
                        win.flip()
                        core.wait(2.0)
                        # Keep track of all the correct responses:
                        practice_correct.append('1')
                    else:
                        win.flip()
                        incorrect_res.draw()
                        win.flip()
                        core.wait(2.0)
                elif colour_order1 == 2: # ORANGE
                    if pairedconditionsx is 94:
                        win.flip()
                        correct_res.draw()
                        win.flip()
                        core.wait(2.0)
                        # Keep track of all the correct responses:
                        practice_correct.append('1')
                    else:
                        win.flip()
                        incorrect_res.draw()
                        win.flip()
                        core.wait(2.0)
                event.clearEvents(eventType='keyboard')
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock.reset()
                break
            elif event.getKeys(keyList=["m"]):
                if colour_order1 == 1: # BLUE
                    if pairedconditionsx is 91 or pairedconditionsx is 92 or pairedconditionsx is 94:
                        win.flip()
                        correct_res.draw()
                        win.flip()
                        core.wait(2.0)
                        # Keep track of all the correct responses:
                        practice_correct.append('1')
                    else:
                        win.flip()
                        incorrect_res.draw()
                        win.flip()
                        core.wait(2.0)
                elif colour_order1 == 2: # ORANGE
                    if pairedconditionsx is 91 or pairedconditionsx is 92 or pairedconditionsx is 93:
                        win.flip()
                        correct_res.draw()
                        win.flip()
                        core.wait(2.0)
                        # Keep track of all the correct responses:
                        practice_correct.append('1')
                    else:
                        win.flip()
                        incorrect_res.draw()
                        win.flip()
                        core.wait(2.0)
                event.clearEvents(eventType='keyboard')
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock.reset()
                break
        # EXPERIMENTAL TRIALS:
        elif ycounter >= 2:
            if event.getKeys(keyList=["escape"]):
                win.flip()
                breaktext.draw()
                win.flip()
                keypressed = event.waitKeys(timeStamped=False)
                checkclock.reset()
            if event.getKeys(keyList=["6"]):
                win.close()
                core.quit()
            # RESPONSE 1: (Left Side)
            if event.getKeys(keyList=["z"]): # MORE OF A COLOUR
                
                # Update pcounter2
                pcounter2 = pcounter2+1
                
                # Update the ycounter
                ycounter = ycounter+1
                
                # Update the xcounter:
                xcounter = xcounter+1
                
                # Collect correct/incorrect responses
                if colour_order1 == 1: # BLUE    
                    if pairedconditionsx is 1 or pairedconditionsx is 3 or pairedconditionsx is 5 or pairedconditionsx is 8:
                        correctresponse2p2.append('1')
                    else:
                        correctresponse2p2.append('0')
                elif colour_order1 == 2: # ORANGE
                    if pairedconditionsx is 2 or pairedconditionsx is 4 or pairedconditionsx is 6 or pairedconditionsx is 8:
                        correctresponse2p2.append('1')
                    else:
                        correctresponse2p2.append('0')
                        
                        
                # Keep track of keys pressed
                keyspressed2p2.append('left')
                
                # Update the counters:
                counter = counter+1
                
                # Keep track of trial number to be saved 
                trialNo2p2.append(counter)
                print('trial number =', trialNo2)
                
                time2 = checkclock.getTime()
                RT2p2.append(time2)
                
                # DRAW FIXATION CROSS AFTER EACH TRIAL
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock.reset()
                event.clearEvents(eventType='keyboard')
                
                # END THE EXPERIMENT HERE AND SAVE DATA
                if counter == pairedtrials:
                    win.flip() # Clears the window
                    endtext1.draw() # Draw ending message here
                    win.flip() # Clears the window
                    core.wait(5.0)
                    win.flip()
                    #####################################################################
                    #Write Data To File
                    #####################################################################
                    
                    # Write RESULTS To A File 
                    os.chdir("Flash_Grid_Results") # move to folder called RESULTS, need to CREATE this if it does not exist already.
                    fout = open(filename, 'w')
                    fout.write('Trial Number, Response, Correct/Incorrect(1/0), RT, Condition, Difficulty, Colour Order (Single Grids Only)\n')
                    for i in range(singletrials):
                        fout.write('%d\t'% trialNo[i],)
                        fout.write('%s\t'% keyspressed[i],)
                        fout.write('%s\t'% correctresponse[i],)
                        fout.write('%.3f\t'% RT[i],)
                        fout.write('%s\t'% conused[i],)
                        fout.write('%s\t'% difflevel[i],)
                        fout.write('%s\t\n'% colourcolour1[i],)
                        
#                        fout.write('\n')
                    for i in range(pairedtrials):
                        fout.write('%d\t'% trialNo2[i],)
                        fout.write('%s\t'% keyspressed2[i],)
                        fout.write('%s\t'% correctresponse2[i],)
                        fout.write('%.3f\t'% RT2[i],)
                        fout.write('%s\t'% conused2[i],)
                        fout.write('%s\t\n'% difflevel2[i],)
                        

                    
#                        fout.write('\n')
                    for i in range(singletrials):
                        fout.write('%d\t'% trialNos2[i],)
                        fout.write('%s\t'% keyspresseds2[i],)
                        fout.write('%s\t'% correctresponses2[i],)
                        fout.write('%.3f\t'% RTs2[i],)
                        fout.write('%s\t'% conused3[i],)
                        fout.write('%s\t'% difflevel3[i],)
                        fout.write('%s\t\n'% colourcolour2[i],)
                        
#                        fout.write('\n')
                    for i in range(pairedtrials):
                        fout.write('%d\t'% trialNo2p2[i],)
                        fout.write('%s\t'% keyspressed2p2[i],)
                        fout.write('%s\t'% correctresponse2p2[i],)
                        fout.write('%.3f\t'% RT2p2[i],)
                        fout.write('%s\t'% conused4[i],)
                        fout.write('%s\t\n'% difflevel4[i],)
                        

                    
                    # Close the results data file
                    fout.close()
                    
                    #Say Where Results Are Written & If Experiment Successful
                    print('Results Written To File Called ' + filename) 
                    print('Program Completed Successfuly.')
                    ####################################################################
                    ####################################################################
                    
                    win.close()
                    core.quit()
                break
                
             # RESPONSE 2: (Right Side)
            if event.getKeys(keyList=["m"]): # LESS OF A COLOUR
                
                # Update pcounter2
                pcounter2 = pcounter2+1
                
                # Update the ycounter
                ycounter = ycounter+1
                
                # Update the ycounter:
                xcounter = xcounter+1
                
                
                # Collect correct/incorrect responses
                if colour_order1 == 1: # If question is more     
                    if pairedconditionsx is 2 or pairedconditionsx is 4 or pairedconditionsx is 6 or pairedconditionsx is 7:
                        correctresponse2p2.append('1')
                    else:
                        correctresponse2p2.append('0')
                elif colour_order1 == 2:
                    if pairedconditionsx is 1 or pairedconditionsx is 3 or pairedconditionsx is 5 or pairedconditionsx is 7:
                        correctresponse2p2.append('1')
                    else:
                        correctresponse2p2.append('0')
                        
                    
                # Keep track of keys pressed:
                keyspressed2p2.append('right')
                
                # Update the counter
                counter = counter+1
                
                # Keep track of trial number to be saved 
                trialNo2p2.append(counter)
                
                time2 = checkclock.getTime()
                RT2p2.append(time2)
                
                # DRAW FIXATION CROSS AFTER EACH TRIAL
                win.flip() # Clears the window
                fcross.draw() # Draw the fixation cross
                win.flip() # Clears the window
                core.wait(1.5) # Keep the cross on screen for 2 seconds
                checkclock.reset()
                event.clearEvents(eventType='keyboard')
                
                # END THE EXPERIMENT HERE AND SAVE DATA
                if counter == pairedtrials:
                    win.flip() # Clears the window
                    endtext1.draw() # Draw ending message here
                    win.flip() # Clears the window
                    core.wait(5.0)
                    win.flip()
                    #####################################################################
                    #Write Data To File
                    #####################################################################
                    
                    # Write RESULTS To A File 
                    os.chdir("Flash_Grid_Results") # move to folder called RESULTS, need to CREATE this if it does not exist already.
                    fout = open(filename, 'w')
                    fout.write('Trial Number, Response, Correct/Incorrect(1/0), RT, Condition, Difficulty, Colour Order (Single Grids Only)\n')
                    for i in range(singletrials):
                        fout.write('%d\t'% trialNo[i],)
                        fout.write('%s\t'% keyspressed[i],)
                        fout.write('%s\t'% correctresponse[i],)
                        fout.write('%.3f\t'% RT[i],)
                        fout.write('%s\t'% conused[i],)
                        fout.write('%s\t'% difflevel[i],)
                        fout.write('%s\t\n'% colourcolour1[i],)
                        
#                        fout.write('\n')
                    for i in range(pairedtrials):
                        fout.write('%d\t'% trialNo2[i],)
                        fout.write('%s\t'% keyspressed2[i],)
                        fout.write('%s\t'% correctresponse2[i],)
                        fout.write('%.3f\t'% RT2[i],)
                        fout.write('%s\t'% conused2[i],)
                        fout.write('%s\t\n'% difflevel2[i],)
                    
#                        fout.write('\n')
                    for i in range(singletrials):
                        fout.write('%d\t'% trialNos2[i],)
                        fout.write('%s\t'% keyspresseds2[i],)
                        fout.write('%s\t'% correctresponses2[i],)
                        fout.write('%.3f\t'% RTs2[i],)
                        fout.write('%s\t'% conused3[i],)
                        fout.write('%s\t'% difflevel3[i],)
                        fout.write('%s\t\n'% colourcolour2[i],)
                        
#                        fout.write('\n')
                    for i in range(pairedtrials):
                        fout.write('%d\t'% trialNo2p2[i],)
                        fout.write('%s\t'% keyspressed2p2[i],)
                        fout.write('%s\t'% correctresponse2p2[i],)
                        fout.write('%.3f\t'% RT2p2[i],)
                        fout.write('%s\t'% conused4[i],)
                        fout.write('%s\t\n'% difflevel4[i],)
                    
                    # Close the results data file
                    fout.close()
                    
                    #Say Where Results Are Written & If Experiment Successful
                    print('Results Written To File Called ' + filename) 
                    print('Program Completed Successfuly.')
                    ####################################################################
                    ####################################################################
                    
                    win.close()
                    core.quit()
                break
                 
        # refresh the screen
        if continueRoutine:  # don't flip if this routine is over or we'll get a blank screen
            win.flip()
        else:  # this Routine was not non-slip safe so reset non-slip timer
            routineTimer.reset()
        
    
        
#-------Ending Routine "show_flash"-------
for thisComponent in show_flashComponents:
    if hasattr(thisComponent, "setAutoDraw"):
        thisComponent.setAutoDraw(False)
########################################################################################
########################################################################################mm
